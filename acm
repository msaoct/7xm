PowerShell:
- PowerShell is a task automation and configuration management framework from Microsoft, consisting of a command-line shell and associated scripting language.
- Initially a Windows component only, known as Windows PowerShell, it was made open-source and cross-platform on 18 August 2016 with the introduction of PowerShell Core.
- The former is built on .NET Framework while the latter on .NET Core.
- In PowerShell, administrative tasks are generally performed by cmdlets (pronounced command-lets), which are specialised .NET classes implementing a particular operation.
- Third-party developers can develop their own cmdlets and add them to PowerShell.
- Sets of cmdlets may be combined into scripts.

PowerShell Background:
Every version of Microsoft Windows for personal computers has included a command line interpreter (CLI) for managing the operating system. Its predecessor, MS-DOS, relied exclusively on a CLI.
These are COMMAND.COM in MS-DOS and Windows 9x, and cmd.exe in the Windows NT family of operating systems.
Microsoft attempted to introduce the Windows Script Host in 1998 with Windows 98, and its command-line based host: cscript.exe.
Different versions of Windows provided various special-purpose command-line interpreters (such as netsh and WMIC) with their own command sets, but they were not interoperable.
By 2002 Microsoft had started to develop a new approach to command line management, including a CLI called Monad (also known as Microsoft Shell or MSH).
Microsoft published the first Monad public beta release on June 17, 2005, Beta 2 on September 11, 2005, and Beta 3 on January 10, 2006.
On April 25, 2006, Microsoft formally announced that Monad had been renamed Windows PowerShell.
PowerShell v2.0 was completed and released to manufacturing in August 2009, as an integral part of Windows 7 and Windows Server 2008 R2.
Versions of PowerShell for Windows XP, Windows Server 2003, Windows Vista and Windows Server 2008 were released in October 2009.
On 18 August 2016, Microsoft announced that they had made PowerShell open-source and cross-platform with support for Windows, macOS, CentOS and Ubuntu.

PowerShell Design:
PowerShell was designed by - A. Jeffrey Snover, Bruce Payette, James Truher.
PowerShell's developers based the core grammar of the tool on that of the POSIX 1003.2 Korn shell.
Windows PowerShell can execute four kinds of named commands:
• cmdlets (.NET Framework programmes designed to interact with PowerShell).
• PowerShell scripts (files suffixed by .ps1).
• PowerShell functions.
• Standalone executable programmes.

Open Powershell:
Run a search for PowerShell on your computer.
You probably have several different options, like “PowerShell,” “PowerShell ISE,” and “PowerShell (x86)”.
The ISE (integrated scripting environment) is a handy tool which allows you to write scripts on the fly, and
also has a convenient look-up for all the PowerShell commands.

Two Ways of Extending PowerShell:
A. PSSnapins:
Definition: PSSnapins are legacy extensions in PowerShell used to add cmdlets, providers, and sometimes types to the environment.
Usage: Loaded using Add-PSSnapin cmdlet.
Example: Add-PSSnapin Microsoft.Exchange.Management.PowerShell.SnapIn
B. Modules:
Definition: Modules are a more modern and flexible way to extend PowerShell, encapsulating cmdlets, functions, variables, and other resources in a structured manner.
Usage: Loaded using Import-Module cmdlet. Automatic loading is also supported in recent PowerShell versions.
Example: Import-Module ActiveDirectory

The four types of FORMAT commands in PowerShell are:
1.Format-Wide:
Purpose: Displays wide, table-like views of selected properties of objects.
Usage Example: Get-Process | Format-Wide -Property Name
2.Format-List:
Purpose: Formats the output as a list of property-value pairs.
Usage Example: Get-Service | Format-List -Property DisplayName, Status
3.Format-Table:
Purpose: Presents tabular data with columns for specified properties.
Usage Example: Get-EventLog -LogName Application | Format-Table -Property TimeGenerated, EntryType, Source
4.Format-Custom:
Purpose: Provides a detailed, customizable view of objects.
Usage Example: Get-Command Format-Custom

Two ways to find all the sql services are on one server in PowerShell:
1.WMI Query for SQL Services:
Command: Get-WmiObject Win32_Service | Where-Object { $_.Name -like "sql" }
Description: Uses WMI (Windows Management Instrumentation) to query all services with names containing "sql" and filters the results.
2.Get-Service for SQL Services:
Command: get-service sql
Description: Utilizes the Get-Service cmdlet with a wildcard pattern to retrieve all services whose names start with "sql."

Platforms of PowerShell:
1. .NET Framework
2. .NET Core

PowerShell Consists of different OS:
1. Windows 7
2. Windows Server 2008 R2
3. Mac OS 10.12
4. Ubuntu

PowerShell commands related to files and directories:
1.mkdir (alias for New-Item):
Command: mkdir NewDirectory
Description: Creates a new directory with the specified name.
2.rm (alias for Remove-Item):
Command: rm File.txt
Description: Removes or deletes a file or directory.
3.ls (alias for Get-ChildItem):
Command: ls -Path C:\Directory
Description: Lists files and directories in the specified path. Can be customized with various parameters for detailed information.
4.mv (alias for Move-Item):
Command: mv SourceFile.txt Destination\
Description: Moves a file or directory to a new location.
5.cp (alias for Copy-Item):
Command: cp SourceFile.txt Destination\
Description: Copies a file or directory to a new location

Command keeps all history in Documents folder and can be accessed even after closing powershell:
To keep a history of PowerShell commands in a file that persists even after closing PowerShell, you can use the Start-Transcript cmdlet. This cmdlet records all output, including errors and input commands, to a text file. Here's how you can use it:
Start-Transcript -Path "$HOME\Documents\PowerShellHistory.txt"
This command starts recording the session and saves it to a text file named "PowerShellHistory.txt" in the Documents folder. After running this command, all your commands and their output will be logged to that file.
To stop recording, you can use the Stop-Transcript cmdlet:
Stop-Transcript
This will close the recording session, and you can find the transcript file in your Documents folder. You can open the transcript file in a text editor to review your command history even after closing PowerShell.

"Get-Command -noun s*" cmdlet:
The Get-Command cmdlet retrieves information about all the cmdlets that are installed on the computer. This includes cmdlets, aliases, functions, filters, scripts, and applications. The -noun parameter specifies that only the cmdlets whose names start with the letter s should be returned.
For example, to get a list of all the cmdlets whose names start with the letter s, you would use the following command:
Get-Command -Noun s*
This would return a list of all the cmdlets whose names start with the letter s, such as Get-Service, Set-Service, and Stop-Service.
The Get-Command cmdlet can be used to get information about a specific cmdlet, or to get a list of all the cmdlets that are installed on the computer. This information can be used to help you learn how to use PowerShell cmdlets, or to troubleshoot problems that you might be having with PowerShell.

"get-help get-service -examples" cmdlet
The get-help get-service -examples cmdlet displays examples of how to use the Get-Service cmdlet.
The Get-Service cmdlet is used to get a list of all the services that are running on a local or remote computer. It can also be used to get information about a specific service, such as its status, startup type, and description.
The get-help get-service -examples cmdlet can be used to learn how to use the Get-Service cmdlet to perform specific tasks, such as:
Getting a list of all the services that are running on a local computer
Getting information about a specific service
Starting, stopping, or restarting a service
Changing the startup type of a service
The get-help get-service -examples cmdlet is a valuable tool for learning how to use the Get-Service cmdlet to manage services on Windows computers.

A powerShell command using pipeline for a child item in path home and search recursively where the length of the file is greater than 20 MB:
Get-ChildItem -Path $HOME -Recurse | Where-Object {$_.Length -gt 20MB} | Select-Object -ExpandProperty FullName
This command will:
-Use Get-ChildItem to list all child items (files and folders) in the user's home directory ($HOME).
-Use the -Recurse parameter to search all subdirectories recursively.
-Pipe the results to Where-Object to filter for items with a Length property greater than 20 Megabytes (MB).
-Pipe the filtered results to Select-Object with the -ExpandProperty parameter to only return the full path of each matching file.
This command will output a list of full paths to all files in your home directory and subdirectories that are larger than 20 MB.

Pipelines in PowerShell:
A pipeline is a powerful feature in PowerShell that allows you to chain commands together, sending the output of one command directly to the next as input. This allows you to build complex workflows and automate tasks efficiently.
Here's an example:
Get all files in the current directory and filter for those with "txt" extension, then sort by size and display the top 5 largest files.
Get-ChildItem -Path . -Filter "*.txt" | Sort-Object -Property Length -Descending | Select-Object -First 5
Breakdown:
-Get-ChildItem retrieves all child items in the current directory.
-Path. specifies the current directory.
-Filter "*.txt" filters for files with the "txt" extension.
-The output is piped to Sort-Object.
-Property Length specifies that sorting should be done based on the "Length" property (file size).
-Descending sorts in descending order, showing the largest files first.
-The output is piped to Select-Object.
-First 5 selects only the first 5 objects in the sorted list.
Sorting Processes by ID:
Here's the command to sort running processes on your computer by ID:
Get-Process | Sort-Object -Property Id -Ascending
Breakdown:
-Get-Process retrieves information about all running processes.
-The output is piped to Sort-Object.
-Property Id specifies that sorting should be done based on the "ID" property.
-Ascending sorts in ascending order, listing processes with the lowest IDs first.
This command will display a list of running processes with their IDs sorted from smallest to largest.

PowerShell Variables:
Variables are the fundamental part of the Windows PowerShell. We can store all the types of values in the PowerShell variables. For example, we can store the result of commands, and the elements which are used in expressions and commands, such as paths, names, settings, and values. In fact, they store the objects specifically, Microsoft .NET Framework objects.
A variable is a unit of memory in which the data is stored. In Windows PowerShell, the name of a variable starts with the dollar ($) sign, such as $process, $a. The name of the variables are not case-sensitive, and they include spaces and special characters. By default, the value of all the variables in a PowerShell is $null.
In PowerShell, variables hold any type of values while executing the commands. The variables store the result from a command, function, and expression. Variables are declared using $ sign before the variable name. For example, to store the output of the Get-Process command in a variable, you would use the following command:
$process = Get-Process
You can then use the $process variable to access the output of the Get-Process command. For example, to display the name of the first process in the $process variable, you would use the following command:
Write-Host $process[0].Name
Variables can also be used to store arrays of data. For example, to store the names of all the processes running on the local computer in an array, you would use the following command:
$processes = Get-Process | Select-Object -Property Name
You can then use the $processes array to access the names of all the processes running on the local computer. For example, to display the name of each process in the $processes array, you would use the following command:
foreach ($process in $processes) {
    Write-Host $process.Name
}
Variables are a powerful tool that can be used to simplify your PowerShell scripts. By using variables, you can avoid repeating the same commands multiple times and you can make your scripts more readable and maintainable.

Types of Variables:
Following are the different types of variables in the Windows PowerShell-
User-created Variables: Those variables which are created and maintained by the user are called user-created variables. The variables that we create at the PowerShell command line exist only while the Window of PowerShell is open. When the Window of PowerShell is closed, the variables are also deleted. We can create the variables in the scripts with the local, global, or script scope.
Automatic Variables: Those variables which store the state of PowerShell are called automatic variables. The PowerShell creates this type of variable, and their values are changed by the PowerShell to maintain their accuracy. The user cannot change the values of these variables.
Preference Variables: Preference variables are those variables that store the user preferences for the Windows PowerShell. The Windows PowerShell creates this type of variable, and they are populated with the default values. Any user can change the value of preference variables.

The key characteristics of PowerShell are:
It is object-based and not text based.
Commands are able to be modified to suit a particular task.
It is a command line interpreter and scripting environment.

Advantages of PowerShell:
Following are the few benefits of a PowerShell:
-It is easy to learn and implement.
-It is an object-based scripting language.
-It provides more functions as compared to VBScript and cmd.exe
-PowerShell supports automation platform, which is also an important factor.
-We can also execute a .NET code in PowerShell.
-In PowerShell, there is no need to specify the "type" of a variable.
-It is also interactive. It allows programmers to try first at a console and then work with more complicated scripts.
-There is a concept of background jobs in PowerShell scripting.
-It provides the feature of Reusability. The scripts which are written once to perform a particular task can be saved for later use. And can be merged with other scripts to perform various tasks. So, repetitive tasks can be performed to execute the tasks. It saves time and money of administrator in configuring the machines.

Disadvantages of PowerShell:
Following are the few disadvantages of PowerShell:
-Framework: It requires .NET framework.
-Object-based: With most shells, the text-based commands are used to get the work done while writing scripts. If a user switches to Windows PowerShell from some other type of shells, he will have to get used to a different way of thinking. Due to this, some users need more time to understand the PowerShell.
-Security risks: Another drawback of using PowerShell is that it can create some potential security risks. Many professionals of IT use it as a way to connect remotely to other servers and computers. During this process, PowerShell can leave some holes open for security breaches. It is the major disadvantages of using PowerShell script.
-Web Server: Another drawback of PowerShell is that it requires a user to run a web server on his server when utilizing remote functionality.

Powershell features:
1. Windows PowerShell Workflow: Workflow capabilities have been introduced in Windows PowerShell version 3.0. It is designed particularly to help us by performing long-time and effort-consuming complex tasks across different and multiple devices at different locations.
2. Desired State Configuration: DSC is the feature of a Windows PowerShell which provides a collection of language extensions, resources, and cmdlets that can be used to configure the software declaratively.
3. Background job: Windows PowerShell introduced the concept of background jobs that run scripts and cmdlets asynchronously on the remote and local machines in the background without affecting the user interface or interacting with the console.
4. Scheduled job: It is similar to the background job. Both the jobs execute asynchronously in the background without affecting the interface, but the main difference is that the background jobs are started manually.
5. Error-handling: Windows PowerShell provides the error-handling mechanism through the Try{ }, Catch { }, and Finally {} blocks as in .NET language.
6. PowerShell remoting: This feature of Windows PowerShell allows the execution of cmdlets on remote systems which help to manage the set of remote computers from one single machine.
7. Script debugging: It is a feature of PowerShell to examine the script, function, command, or expressions while PowerShell is running. PowerShell script debugger includes the set of cmdlets which allow to set and manage breakpoints and view the call stack.
8. Tab expansion: Tab expansion is an implementation of auto-completion, which completes the cmdlets, properties, and parameter names by pressing the Tab key once.
9. Steppable pipeline: This feature allows the splitting of script blocks into a steppable pipeline. And then it gives the option to call the begin(), process(), and end() methods of script block to control the execution sequence.
10. Constrained runspaces: It allows the creation of PowerShell runspaces with the set of constraints which includes the ability to access and execution of scripts, cmdlets, and language elements.
11. Windows PowerShell web access: PowerShell console introduced a web-based version in Windows Server 2012. Here, we can run PowerShell cmdlets from any web browser which is not available on desktops but also on any tablet or mobile devices.
12. Network file transfer: This feature provides the native support for prioritized, and asynchronous transfer of files between the machines using BITS (Background Intelligent Transfer Service).
13. Windows PowerShell Integrated Scripting Environment (ISE): It is the host GUI based application for the Windows PowerShell. This feature provides tab completion, multiline editing, syntax coloring, context-sensitive help, selective execution, and support for right-to-left languages.
14. Transactions: This feature of Windows PowerShell enables us to start a transaction, to indicate which command is a part of it, and to either rollback or commit a transaction.

PowerShell Comments:
When you want to help others by providing the information about a code, then you must use the comments in that code.
Just like other programming or scripting languages, you can give the comments in a PowerShell for the documentation purpose.
In PowerShell, there are two types of comments:
1) Single-line Comment - Single line comments are those comments in which you can type a hash symbol # at the beginning of each line. Everything to the right of the hash symbol will be ignored. If you write the multiple lines in a script, you had to use the hash # symbol at the starting of each line.
2) Multiple-line comment or comment block - With PowerShell 2.0 or above, multiple line comments or block comments have been introduced. To comment the multiple lines, put the <# symbol at the beginning of the first line and #> symbol at the end of the last line.

Function of $input Variable:
Input Handling: $input is an automatic variable in PowerShell that represents the input to a function or script.
Iterative Processing: It allows access to input data, making it useful for processing items within a loop or pipeline.
Enumerator: $input acts as an enumerator, facilitating the handling of input streams.

Rename a Variable in PowerShell:
Set-Variable Cmdlet: Use Set-Variable cmdlet to change the name of a variable.
Example: $oldName = 'Original'; Set-Variable -Name 'NewName' -Value $oldName
Note: Directly assigning a new name is not supported.

Difference between Function and Advanced Function:
Parameters: Advanced functions support parameter attributes like [Parameter()] for enhanced parameter control.
Cmdlet Binding: Advanced functions support cmdlet binding, making them behave more like cmdlets.
Common Parameters: Advanced functions automatically support common parameters like -Verbose, -Debug, etc.
ScriptBlock: Both functions and advanced functions use a script block to define their behavior.


Importing Data into PowerShell:
PowerShell offers a variety of ways to import data.
We will be going over just a few of the ways in this article, but a lot of the concepts stay the same no matter which way you need to use.
The general guideline we follow is:
• Import the data
• Validate the data
• Iterate through the data and take actions
• Export data when needed
Text Files:
While this method is not as structured as others, it can really be handy in a pinch.
You can copy and paste a list of users, computers, or anything else you want to iterate through, and then save
it as a text file.
Once you have a file, you can use PowerShell to import the contents.
For this example, will import the contents of Cities.txt.
>$Cities = Get-Content C:\Users\niks\Desktop\Cities.txt
>$Cities
The contents have been successfully imported. We can see what type of object we're working with by piping $Cities to Get-Member.
>$Cities | Get-Member
Looks like we are working with an array of strings. We can see this by using the Count property, as well as taking a look at the first value in the array, which would be reflected as $Cities[0].
>$Cities[0]
CSV Files:
PowerShell works nicely with CSV files. This method of importing data is a bit more structured, and overall is very clean.
The headers of the CSV file will be imported as properties, and we'll take a look at that after we import the contents.
For this example, I will import a CSV file that contains a list of users that HR wants us to create in our environment.
I will use the command Import-CSV and store the contents in the variable $Users.
Let us go ahead and import the CSV:
>$Users = Import-CSV C:\Users\niks\Desktop\ADUsers.csv
>$Users
Let us see what we have when we pipe $Users to Get-Member.
>$Users | Get-Member
Looks like CSVs are imported into a custom object, which we can then use as needed!
We can use the Count property to get the number of users imported, as well as take a look at the first value ($Users[0]) of the array.
>$Users[1]

Navigation in Powershell:
A nice thing about PowerShell is you always know where you are because it tells you in the prompt.
PS C:\Users\niks>
Our first command is Get-ChildItem.
Go ahead and type it in, and hit enter.
You’ll see a list of everything in your current directory.
PS C:\Users\niks> gci

Moving Between Directories in Powershell:
To move to your desktop, we will use the Set-Location cmdlet. Enter
PS C:\Users\niks> sl .\Desktop\
PS C:\Users\niks\Desktop>
We can move back to the YOURUSERNAME directory by typing, Don’t leave out the space!
PS C:\Users\niks\Desktop> sl
PS C:\Users\niks>

Creating New Directories:
Let us make a directory where we can store everything we are using for this lesson. Navigate back home by typing
PS C:\Users\niks\Desktop> sl ~
PS C:\Users\niks>
We’ll make a new directory inside of your YOURUSERNAME directory.
To do this, we use the command mkdir.
Call your directory whatever you want, but try not to use spaces, as these make working on the command line more complicated than necessary.
PS C:\Users\niks> mkdir abc

Deletion:
Now that you can see the results of what you are doing in PowerShell. Let us learn to delete things - for
instance, that directory with the long name. First, create a few more directories. Name them “dir,” “dir1,”and “dir2.” You can make all three with a single command by typing-
PS C:\Users\niks> mkdir dir, dir1, dir2
Now, let us get rid of that long-named directory. To do this, we use the cmdlet Remove-Item or just rm. You have to be very careful with this cmdlet, because it does not put things in your recycle bin. It deletes them permanently. Gone. Type in rm followed by a space and the long-named directory’s name. You’ll probably want to use tab for auto-completion.
PS C:\Users\niks> rm .\dir\
Multiple deletes at a time is possible-
PS C:\Users\niks> rm dir1 dir2

Find Powershell commands:
• The first thing to keep in mind is that in Windows PowerShell, not everything is a cmdlet.
• There are language statements, functions, aliases, various objects (from the .NET Framework or COM), and even other executables—all of which are utilisable from within Windows PowerShell.
• In Windows 8 Consumer Preview, this means you have around 1000 commands from which to choose.
• In Windows 7, the situation is not quite so overwhelming, but still, you need to know how to find what you want.
Two cmdlets are essential for discovering Windows PowerShell commands.
The first is the Get-Command cmdlet, and the second is the Get-Help cmdlet.
At first glance, the Get-Command cmdlet might not appear to be all that useful. For example, you provide it with the name of a cmdlet, and basically what returns is the name of the cmdlet.
This command is shown below:
PS C:\Users\niks> Get-Command Get-Process
• The command and the output associated with the command illustrate the problem.
• The default output does not appear to display much more information than you knew when you typed in the command.
• You figured it was a cmdlet, you knew the name of Get-Process, and the definition does not add much additional information.
Point to remember, everything in Windows PowerShell is an object. In fact, the Get-Command cmdlet returns a CmdletInfo object. 

Get-Command:
The PowerShell Get-Command cmdlet is used to get a list of all the PowerShell commands that are installed on the computer. This cmdlet includes functions, other cmdlets, aliases, filters, scripts, and applications. You can use the Get-Command cmdlet to get only those commands that have been imported into the current session by using the -ListImported parameter. With the starting of Windows PowerShell 5.0, this cmdlet displays a version column by default.

Active Directory and PowerShell:
• The one thing that makes system administration on the Windows platform unique is its interaction with Active Directory.
• As the centralised authorisation, authentication, and information store for Windows networks, Active Directory automation forms the core of many enterprise administration tasks.
• In PowerShell version one, the primary way to interact with Active Directory came through its support for Active Directory Service Interface (ADSI) type shortcuts.
• While PowerShell version two was under development, the Active Directory team created an immensely feature-filled PowerShell module to manage Active Directory domains.
Working with the Active Directory module has two requirements:
Support from the server: This module works with any domain that has enabled the Active Directory Web Services feature. Windows Server 2008 R2 enables this feature by default on Active Directory instances, and you can install it on any recent server operating system from Windows Server 2003 on.
Support from the client: The module itself is included in the Windows 7 Remote Server Administration Tools (RSAT) package. After downloading and installing the package, you can enable it through the “Turn Windows Features On or Off” dialogue in the Control Panel. The Active Directory module for Windows PowerShell is a PowerShell module that consolidates a group of cmdlets.
You can use these cmdlets to manage your Active Directory domains, Active Directory Lightweight Directory Services (AD LDS) configuration sets, and Active Directory Database Mounting Tool instances in a single, self-contained package.
If you do not have the Active Directory module installed on your machine, you need to download the correct Remote Server Administration Tools (RSAT) package for your OS.
If you are running Windows 7, you will also need to run the import-module Active Directory command from an elevated PowerShell prompt.

Fan-in and fan-out in PowerShell:
Fan-in and fan-out are two terms that are used to describe the behavior of data flowing through a system. Fan-in refers to the number of inputs that a component can have, while fan-out refers to the number of outputs that a component can have.
In PowerShell, fan-in and fan-out can be used to describe the behavior of data flowing through a pipeline. For example, a cmdlet that takes multiple inputs and produces a single output can be said to have fan-in of 1 and fan-out of 1. A cmdlet that takes a single input and produces multiple outputs can be said to have fan-in of 1 and fan-out of N, where N is the number of outputs.
Fan-in and fan-out can also be used to describe the behavior of data flowing through a script. For example, a script that calls multiple cmdlets in sequence can be said to have fan-in of 1 and fan-out of N, where N is the number of cmdlets that are called. A script that calls multiple cmdlets in parallel can be said to have fan-in of N and fan-out of 1, where N is the number of cmdlets that are called.

Error handling in PowerShell:
PowerShell error handling is the process of identifying, catching, and handling errors that occur while a PowerShell script is running. Error handling is important because it allows you to gracefully handle errors and continue executing the script, rather than having the script fail completely.
There are two main ways to handle errors in PowerShell:
Using the try and catch blocks:
The try and catch blocks allow you to specify a block of code that should be executed, and a block of code that should be executed if an error occurs in the try block.
Using the $ErrorAction variable:
The $ErrorAction variable controls how PowerShell handles errors.
The best way to handle errors in PowerShell depends on the specific script you are writing. However, using the try and catch blocks is generally the best way to handle errors, as it allows you to gracefully handle errors and continue executing the script.

Persistent Connection in Powershell:
In PowerShell, a persistent connection is a connection that stays open after the command has finished. This is in contrast to a non-persistent connection, which is closed after the command has finished.
Persistent connections can be used to improve performance when you are running multiple commands that share data. For example, if you are running a script that imports data from a CSV file, you can use a persistent connection to the CSV file so that you do not have to open and close the file each time you import data.
To create a persistent connection in PowerShell, you can use the New-PSSession cmdlet. The New-PSSession cmdlet creates a new PowerShell session on a remote computer. The session remains open until you close it.
Once you have created a persistent connection, you can use the Enter-PSSession cmdlet to enter the session. The Enter-PSSession cmdlet allows you to run commands on the remote computer as if you were running them on the local computer.
When you are finished running commands on the remote computer, you can use the Exit-PSSession cmdlet to exit the session. The Exit-PSSession cmdlet closes the persistent connection.
Here is an example of how to use a persistent connection in PowerShell:
New-PSSession -ComputerName server01
Enter-PSSession -Session server01
Get-Process
Exit-PSSession
In this example, the New-PSSession cmdlet creates a new PowerShell session on the computer server01. The Enter-PSSession cmdlet enters the session. The Get-Process cmdlet gets a list of all the processes running on the computer server01. The Exit-PSSession cmdlet exits the session.

Creating a random password using PowerShell:
1. Importing the necessary Assemblies:
System.Security.Membership
System.Management.Automation
2. Defining the Function:
Name: Get-RandomPassword
Parameters:
PasswordLength (optional, default: 12)
MinimumSpecialCharacters (optional, default: 2)
3. Generating the Character Sets:
Lowercase letters
Uppercase letters
Numbers
Special characters (e.g., !@#$%^&*()_+-)
4. Selecting Random Characters:
Use the Get-Random cmdlet to randomly select characters from each set.
Guarantee at least the MinimumSpecialCharacters amount of special characters.
Ensure the password length is met.
5. Combining Characters into a Password String:
Use the -join operator to combine the selected characters into a single string.
6. Returning the Password: Return the generated password string as the function output.

To enable Active Directory in Windows 10, you can do the following: 
Install the remote server administration tools on Windows 10 Professional or Enterprise.
Go to Control Panel
Select Programs
Select Turn Windows features on or off
Scroll down and select Remote Server Administration Tools
Expand Role Administrator Tools
Select AD DS and AD LDS Tools
Check AD DS Tools and press Ok
You can also enable Active Directory Users and Computers (ADUC) by doing the following: 
Go to Settings
Select Apps and Features
Select Optional features
Select Add a feature
Select RSAT: Active Directory Domain Services and Lightweight Directory Tools
Select Install
To launch ADUC, you can do the following: 
Click Start
Select System and Security
Select Administrative Tools
Select Active Directory Users and Computers




Network configuration cmdlets:
Network troubleshooting is part of any System Administrator’s life.
Maybe you need to check the IP address of a machine or test if its networking connection is working.
Maybe you need to see if DNS is properly configured or check the latency between two hosts.
If you have been in this field long enough, you probably have a few favourite commands that you learned years ago and use on a regular basis, like IPCONFIG or PING.
There are literally hundreds of networking-related PowerShell cmdlets in Windows these days. 
Just try out this command on your machine: Get-Command -Module Net* | Group Module
But more important than knowing every one of them, is to know the most useful cmdlets that have the potential to replace those old commands that you cannot live without.
And it’s when you combine the many networking cmdlets in ways that only PowerShell can do that you’ll find amazing new troubleshooting abilities.

IPCONFIG:
This command has many options, but the most common usage is just to show the IP address, subnet mask and default gateway for each network adapter in a machine.
Get-NetIPConfiguration or Get-NetIPAddress
Sample command lines:
Get-NetIPConfiguration
Get-NetIPAddress | Sort InterfaceIndex | FT InterfaceIndex, InterfaceAlias, AddressFamily,
IPAddress, PrefixLength -Autosize
Get-NetIPAddress | ? AddressFamily -eq IPv4 | FT –AutoSize
Get-NetAdapter Wi-Fi | Get-NetIPAddress | FT -AutoSize

PING:
Checks connectivity to a specific host. Commonly used to check for liveliness, but also used to measure network latency.
Test-NetConnection
Sample command lines:
Test-NetConnection www.microsoft.com
Test-NetConnection -ComputerName www.microsoft.com -InformationLevel Detailed
Test-NetConnection -ComputerName www.microsoft.com | Select –ExpandProperty
PingReplyDetails | FT Address, Status, RoundTripTime

NSLOOKUP:
Name server lookup. Mostly used to find the IP address for a given DNS name (or vice-
versa). Has many, many options.
Resolve-DnsName
Sample command lines:
Resolve-DnsName www.microsoft.com
Resolve-DnsName microsoft.com -type SOA
Resolve-DnsName microsoft.com -Server 8.8.8.8 –Type A

ROUTE:
Shows the IP routes in a given system (also used to add and delete routes)
Get-NetRoute (also New-NetRoute and Remove-NetRoute)
Sample command lines:
Get-NetRoute -Protocol Local -DestinationPrefix 192.168*
Get-NetAdapter Wi-Fi | Get-NetRoute

NETSAT:
Shows current TCP/IP network connections.
Get-NetTCPConnection
Sample command lines:
Get-NetTCPConnection | Group State, RemotePort | Sort Count | FT Count, Name –Autosize
Get-NetTCPConnection | ? State -eq Established | FT –Autosize
Get-NetTCPConnection | ? State -eq Established | ? RemoteAddress -notlike 127* | % { $_; Resolve-DnsName $_.RemoteAddress -type PTR -ErrorAction SilentlyContinue }

The Powershell Pipeline:
• Pipelines act like a series of connected segments of pipe.
• Items moving along the pipeline pass through each segment.
• To create a pipeline in PowerShell, you connect commands together with the pipe operator "|".
• The output of each command is used as input to the next command.
• The notation used for pipelines is similar to the notation used in other shells.
• At first glance, it may not be apparent how pipelines are different in PowerShell.
• Although you see text on the screen, PowerShell pipes object, not text, between commands.
• Pipelines are arguably the most valuable concept used in command-line interfaces.
• When used properly, pipelines reduce the effort of using complex commands and make it easier to see the flow of work for the commands.
• Each command in a pipeline (called a pipeline element) passes its output to the next command in the pipeline, item-by-item.
• Commands don't have to handle more than one item at a time.
• The result is reduced resource consumption and the ability to begin getting the output immediately.

Objects in the pipeline:
When you run a cmdlet in PowerShell, you see text output because it is necessary to represent objects as text in a console window. The text output may not display all of the properties of the object being output.
For example, consider the Get-Location cmdlet.
When you pipe the output to the Get-Member cmdlet you get information about the object returned by Get-Location.

Selecting object:
You can use the Select-Object cmdlet to create new, custom Windows PowerShell objects that contain properties selected from the objects you use to create them. Type the following command to create a new object that includes only the Name and FreeSpace properties of the Win32_LogicalDisk WMI class.
Get-WmiObject -Class Win32_LogicalDisk | Select-Object -Property Name, FreeSpace

Sorting Objects:
We can organise displayed data to make it easier to scan by using the Sort-Object cmdlet. Sort-Object takes the name of one or more properties to sort on and returns data sorted by the values of those properties. Consider the problem of listing Win32_SystemDriver instances. 
If we want to sort by State and then by Name, we can do it by typing:
Get-WmiObject -Class Win32_SystemDriver | Sort-Object -Property State,Name | Format-Table -Property Name,State,Started,DisplayName - AutoSize -Wrap
You can also sort the objects in reverse order by specifying the Descending parameter. The reverses sort order, so that names are sorted in reverse alphabetical order and numbers are sorted by descending size.
Get-WmiObject -Class Win32_SystemDriver | Sort-Object -Property State,Name -Descending | Format-Table -Property Name,State,Started,DisplayName - AutoSize -Wrap

Filtering Objects:
• The key to making the most of Windows PowerShell is to understand how objects and the pipeline wor together to let you retrieve exactly the information you need.
• Each command in the pipeline generates one or more objects and passes them down the pipeline to the next command.
• Integral to this process is the ability to filter the objects and their data as they pass from one command the next.
• To that end, PowerShell includes a number of cmdlets that, in one way or another, let you create commands that refine your pipeline's output.
Here we discuss five of those cmdlets-
• Where-Object: Where-Object is one of the most commonly used cmdlets in PowerShell and probably the one most often used for filtering data. This cmdlet filters objects passed down the pipeline based on the search criteria you specify in a script block included with the cmdlet. In other words, the script block determines which objects are permitted to continue down the pipeline and which are not.
• Select-Object: There might be times when you need to refine your results a bit differently from what the Where-Object cmdlet provides. That is where the Select-Object cmdlet comes in. Using this cmdlet, you can filter your results based on property names, a number of objects, or other criter For example, the statement pipes the Get-Process cmdlet's output to the Select-Object cmdlet and specific that only the ProcessName and CPU properties be returned.
• Select-String: The Select-String cmdlet lets you move into new territory: You can use it to search an input string or a file's contents for a specific value. This cmdlet searches for text or text patterns within the target data and returns matching the content. It operates on a line-by-line basis, filtering out all lines that don't contain the specified string and returning those that do. In addition, the cmdlet lets you specify that nonmatching lines are returned instead of matching lines. You can even test for the existence of matches, without returning the actual data.
• ForEach-Object: The ForEach-Object cmdlet in PowerShell is used to perform an operation on each item in a collection or pipeline. It allows you to iterate through a collection of objects and apply a script block to each item. This cmdlet is commonly used in pipelines to perform actions on individual items as they pass through. ForEach-Object iterates through each item in a collection or pipeline, applying a script block to perform customized actions on individual objects. Example: 1, 2, 3, 4 | ForEach-Object { $_ * 2 } multiplies each number by 2, yielding 2, 4, 6, 8.
• Out-GridView: The last PowerShell cmdlet related to filtering that I want to demonstrate is the Out-GridView cmdlet. This cmdlet sends your output to a new window that displays your data in a grid. You can then filter the returned data however you want, without having to generate additional PowerShell commands. To open the grid window, you simply pipe your results to the Out-GridView cmdlet.

Sending pipeline data as output:
The Out-File cmdlet sends output to a file.
You can use this cmdlet instead of the redirection operator (>) when you need to use its parameters.
This command sends a list of processes on the computer to the Process.txt file. If the file does not exist, Out-File creates it.
• The Out cmdlets do not format objects; they just render them and send them to the specified display destination.
• If you send an unformatted object to an Out cmdlet, the cmdlet sends it to a formatting cmdlet before rendering it.
• The Out cmdlets do not have parameters for names or file paths.
• To send data to a cmdlet that contains the Out verb (an Out cmdlet), use a pipeline operator (|) to send the output of a PowerShell command to the cmdlet.
• You can also store data in a variable and use the InputObject parameter to pass the data to the cmdlet

Cmdlet:
The cmdlets in a PowerShell perform an action and returns a Microsoft .NET framework object to the next command in the pipeline. Cmdlets can receive objects as input and can also output their results as objects, which makes them suitable for use as recipients in a pipeline.
If you write a cmdlet, you must implement a cmdlet class which derives from one of two specialized cmdlet base classes. A derived class must:
-Declare an attribute which identifies the derived class as a cmdlet.
-Define the public properties which are decorated with the attributes that identify the public properties as parameters of a cmdlet.
-To process records, it overrides one or more of the input processing methods.
-An assembly can be loaded which contains the class directly by using an Import-Module cmdlet, or we can create a host application which loads the assembly by using a System.Management.Automation.Runspaces.Initialsessionstate API. Both methods provide programmatic and command-line access to cmdlet functionality.

Cmdlets vs Command:
A cmdlet or "Command let" is a lightweight command used in the Windows PowerShell environment. The Windows PowerShell runtime invokes these cmdlets at command prompt. You can create and invoke them programmatically through Windows PowerShell APIs.
Cmdlets are way different from commands in other command-shell environments in the following manners −
Cmdlets are .NET Framework class objects; and not just stand-alone executables.
Cmdlets can be easily constructed from as few as a dozen lines of code.
Parsing, error presentation, and output formatting are not handled by cmdlets. It is done by the Windows PowerShell runtime.
Cmdlets process works on objects not on text stream and objects can be passed as output for pipelining.
Cmdlets are record-based as they process a single object at a time.

Powershell Looping:
PowerShell loops are used to repeat a set of commands until a certain condition is met. They are an essential part of programming, and PowerShell is no exception. Loops allow you to iterate through collections and repeat tasks until a condition is met. Loops can drastically enhance your PowerShell scripts and take your automation to the next level.
There are four main types of loops in PowerShell:
For Loop:The for loop is commonly used when the number of times (iteration count) a command or process needs to run, is already known.
ForEach-Object Loop:The foreach loop is used to iterate through a collection of objects.
While Loop:The while loop is used to repeat a set of commands until a certain condition is met.
Do While Loop:The do while loop is similar to the while loop, but the condition is checked at the end of the loop instead of the beginning.

ForEach Loop:
In PowerShell, the ForEach loop is used to iterate over elements in a collection (array, hash table, etc.) and perform a specific operation for each element.
One of the subjects that administrators who are new to PowerShell sometimes have difficulty with is ForEach loops.
A ForEach loop is generally used to perform some sort of action against the individual items within a data set.
The data set can be anything. It might consist of a list of processes, a list of disks, or even a list of servers.
That being the case, the first thing that you will have to do if you want to use a ForEach loop is to define the data set by mapping the data to a variable.
There are a few different ways to use the ForEach loop in PowerShell. Here are two common methods:
Method 1: foreach Statement:
# Example 1: Using foreach with an array
$fruits = @('Apple', 'Banana', 'Orange')
foreach ($fruit in $fruits) {
    Write-Output "Current fruit: $fruit"
}
# Example 2: Using foreach with a range of numbers
foreach ($number in 1..5) {
    Write-Output "Current number: $number"
}

Method 2: ForEach-Object Cmdlet:
# Example 3: Using ForEach-Object with the pipeline
$fruits = @('Apple', 'Banana', 'Orange')
$fruits | ForEach-Object {
    Write-Output "Current fruit: $_"
}
# Example 4: Using ForEach-Object with Get-ChildItem cmdlet
Get-ChildItem C:\Files | ForEach-Object {
    Write-Output "File Name: $_.Name"
}
In these examples:
The foreach statement is used to iterate through each element in the array or range of numbers. The variable ($fruit or $number) takes on each value in the collection during each iteration.
The ForEach-Object cmdlet is used with the pipeline (|) to process each item in the input collection. The $_ represents the current object in the pipeline.
Both methods achieve similar results, and you can choose the one that fits your preference or specific use case. The ForEach loop is handy for automating repetitive tasks or processing items in a collection.


Powershell - Conditions:
Decision making structures have one or more conditions to be evaluated or tested by the program, along with a statement or statements that are to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.
PowerShell scripting language provides following types of decision making statements.
1. if statement: An if statement consists of a boolean expression followed by one or more statements.
$number = 42
if ($number -gt 0) {
    Write-Output "$number is a positive number."
}
2. if...else statement: An if statement can be followed by an optional else statement, which executes when the boolean expression is false.
$temperature = 25
if ($temperature -ge 30) {
    Write-Output "It's a hot day!"
} else {
    Write-Output "It's not too hot today."
}
3. nested if statement: You can use one if or elseif statement inside another if or elseif statement(s).
$grade = 85
if ($grade -ge 90) {
    Write-Output "Excellent!"
} elseif ($grade -ge 70) {
    Write-Output "Good."
    if ($grade -ge 80) {
        Write-Output "You're doing well!"
    }
} else {
    Write-Output "Need improvement."
}
4. switch statement: A switch statement allows a variable to be tested for equality against a list of values.
$day = "Wednesday"
switch ($day) {
    "Monday" { Write-Output "Start of the week." }
    "Friday" { Write-Output "Almost the weekend!" }
    default { Write-Output "It's a regular day." }
}


Powershell - Scripting:
Windows PowerShell is a command-line shell and scripting language designed especially for system administration. Its analogue in Linux is called as Bash Scripting. Built on the .NET Framework, Windows PowerShell helps IT professionals to control and automate the administration of the Windows operating system and applications that run on Windows Server environment.
Windows PowerShell commands, called cmdlets, let you manage the computers from the command line. Windows PowerShell providers let you access data stores, such as the Registry and Certificate Store, as easily as you access the file system.
In addition, Windows PowerShell has a rich expression parser and a fully developed scripting language. So in simple words you can complete all the tasks that you do with GUI and much more. Windows PowerShell Scripting is a fully developed scripting language and has a rich expression parser/
Features:
Cmdlets − Cmdlets perform common system administration tasks, for example managing the registry, services, processes, event logs, and using Windows Management Instrumentation (WMI).
Task oriented − PowerShell scripting language is task based and provide supports for existing scripts and command-line tools.
Consistent design − As cmdlets and system data stores use common syntax and have common naming conventions, data sharing is easy. The output from one cmdlet can be pipelined to another cmdlet without any manipulation.
Simple to Use − Simplified, command-based navigation lets users navigate the registry and other data stores similar to the file system navigation.
Object based − PowerShell possesses powerful object manipulation capabilities. Objects can be sent to other tools or databases directly.
Extensible interface. − PowerShell is customizable as independent software vendors and enterprise developers can build custom tools and utilities using PowerShell to administer their software.

Uses of PowerShell Pipiline:
The PowerShell pipeline is a feature of the PowerShell shell and scripting language that allows you to chain together commands to build a single 'pipeline' which simplifies code, allows parallel processing and more.
Commands in a pipeline act like human runners in a relay race. The output of one command is passed as the input to the next command, and so on. This allows you to automate complex tasks with just a few lines of code.
For example, we can use the pipeline to:
-Get a list of all the files in a directory, and then sort them by size.
-Get the contents of a website, and then extract all the links.
-Convert a video file to a different format, and then compress it.

Making up of Variables in powershell:
Name: Starts with $, alphanumeric and some special characters.
Data type: String, integer, decimal, boolean, array, hashtable, object.
Scope: Global, script, local.
Value: Actual data stored.
Special: Predefined variables start with _.
Preference: Control PowerShell behavior.
PowerShell variables are containers that store data. They can be used to store any type of data, including strings, integers, arrays, and objects. Variables are named using the dollar sign ($) followed by the variable name. For example, the following code creates a variable called $name and assigns it the value "John Doe":
$name = "John Doe"
To access the value of a variable, you simply use the variable name. For example, the following code prints the value of the $name variable to the console:
Write-Host $name
Variables can also be used in expressions. For example, the following code creates a variable called $age and assigns it the value 30. It then uses the $age variable in an expression to calculate the person's retirement age:
$age = 30
$retirementAge = $age + 65
Variables can be used to store data that is needed throughout a script. They can also be used to pass data between different scripts. Variables are a powerful tool that can make your PowerShell scripts more efficient and easier to read.

PowerShell Operators:
1. Arithmetic Operators:
Definition: Perform mathematical operations on values.
Operator Names: + (Addition), - (Subtraction), * (Multiplication), / (Division), % (Modulus)
2. Assignment Operators:
Definition: Assign values to variables.
Operator Names: = (Assignment), += (Add and Assign), -=, *=, /=, %=
3. Comparison Operators:
Definition: Compare values and return a Boolean result.
Operator Names: -eq (Equal), -ne (Not Equal), -gt (Greater Than), -lt (Less Than), -ge (Greater Than or Equal), -le (Less Than or Equal)
4. Logical Operators:
Definition: Combine or modify Boolean values.
Operator Names: -and (Logical AND), -or (Logical OR), -not (Logical NOT)
5. Redirectional Operators:
Definition: Control input/output redirection.
Operator Names: > (Output to a file), < (Input from a file), >> (Append to a file)
6. Split and Join Operators:
Definition: Split and join strings.
Operator Names: -split (Split a string), -join (Join elements into a string)
7. Type Operators:
Definition: Check and manipulate data types.
Operator Names: -is (Is of a certain type), -as (Casting or conversion)
8. Unary Operators:
Definition: Operate on a single operand.
Operator Names: - (Negation), + (Unary plus), ! (Logical NOT)

Uses/Needs/Importance of powershell:
-It is both a scripting language and a command-line Shell.
-It can interact with a different number of technologies.
-Windows PowerShell allows complete access to all the types in the .NET framework.
-PowerShell is object-based.
-Many interfaces of GUI that Microsoft designed for its various products are front end interfaces to PowerShell.
-It is more secure than running VBScript or other scripting languages.
-It allows performing repetitive tasks more efficiently by combining multiple commands and by writing scripts. Suppose, a system administrator wants to create hundreds of active directory users, he can achieve this with the help of only some PowerShell cmdlets placed in a script.
-Many complex and time-consuming configurations and tasks can be done in a second with simple cmdlets of PowerShell.

Powershell - Brackets:
There are three types of brackets in PowerShell:
Round/Parenthesis brackets ()
are used for grouping arguments and expressions. For example, the expression (1 + 2) * 3 will be evaluated as (1 + 2) * 3 = 9.
Square brackets []
are used for indexing arrays and accessing hash table elements. For example, the expression $array will return the first element of the array $array.
Curly brackets {}
are used for creating blocks of code. For example, the following code will create a loop that prints the numbers from 1 to 10:
for ($i = 1; $i -le 10; $i++) {
    Write-Host $i
}


Significance of brackets in PowerShell:
The significance of brackets in PowerShell is that they allow you to control the order of operations in expressions and to create blocks of code. This can make your code more readable and easier to maintain.
-Script Blocks: {} define script blocks for encapsulating commands.
-Scope: Establish variable scope within a script block.
-Array Declaration: Brackets @() represent arrays in PowerShell.
-Hashtable Declaration: Curly braces {} define hashtables for key-value pairs.

PSProviders:
PSProviders Describes how Windows PowerShell providers provide access to data and components that would not otherwise be easily accessible at the command line.
The data is presented in a consistent format that resembles a file system drive.
Windows PowerShell providers are Microsoft .NET Framework-based programs that make the data in a specialised data store available in Windows PowerShell so that you can view and manage it.
The data that a provider exposes appears in a drive, and you access the data in a path like you would on a hard disk drive.
You can use any of the built-in cmdlets that the provider supports to manage the data in the provider drive. And, you can use custom cmdlets that are designed especially for the data.
The providers can also add dynamic parameters to the built-in cmdlets.
These are parameters that are available only when you use the cmdlet with the provider data.
Windows PowerShell includes a set of built-in providers that you can use to access the different types of data stores.
You can also create your own Windows PowerShell providers, and you can install providers that others develop. To list the providers that are available in our session, do as:
Get-PSProvider

Installing and removing providers:
Providers are typically installed via Windows PowerShell modules.
Importing the module loads the provider into your session.
You cannot uninstall the built-in providers.
You can uninstall providers loaded by other modules.
You can unload a provider from the current session.
You can do this by using the Remove-Module cmdlet.
This cmdlet does not uninstall the provider, but it makes the provider unavailable in the session.

PSDrives:
A Windows PowerShell drive is a data store location that you can access like a file system drive in Windows PowerShell.
The Windows PowerShell providers create some drives for you, such as the file system drives (including C: and D:), the registry drives (HKCU: and HKLM:), and the certificate drive (Cert:), and you can create your own Windows PowerShell.
These drives are very useful, but they are available only within Windows PowerShell. You cannot access them by using other Windows tools, such as File Explorer or Cmd.exe.

Working with PSDrives:
Windows PowerShell uses the noun, PSDrive, for commands that work with Windows PowerShell. For a list of the Windows PowerShell in your Windows PowerShell session, use the Get- PSDrive cmdlet.
File system drives are a subset of the Windows PowerShell. You can identify the file system drives by the Filesystem entry in the Provider column.
To see the syntax of the Get- PSDrive cmdlet, type a Get-Command command with the Syntax parameter:
Get-Command -Name Get-PSDrive -Syntax
The PSProvider parameter lets you display only the Windows PowerShell that are supported by a particular provider.
For example, to display only the Windows PowerShell that are supported by the Windows PowerShell FileSystem provider, type a Get- PSDrive command with the PSProvider parameter and the FileSystem value:
Get-PSDrive -PSProvider FileSystem
To view the Windows PowerShell that represent registry hives, use the PSProvider parameter to display only the Windows PowerShell that are supported by the Windows PowerShell Registry
Get-PSDrive -PSProvider

Enable remoting on a single local machine:
• With the combined release of Windows PowerShell and WS-Management (WSMan) into the Windows Management Framework, we’ve heard the occasional question about whether it’s possible to install them independently.
• This concern is usually focused on security.
• As a background, Windows Remote Management (WinRM) has been part of the operating system since Windows Vista and Server 2008.
• WinRM does not listen to network connections by default, and it must be explicitly activated.
• Both Windows PowerShell and WinRM advanced greatly during the release of version two—most notably by working together to support a rich Windows PowerShell-based remoting experience.
• The Windows Management Framework download (Windows PowerShell + WinRM) simply updates the binaries on supported operating systems to bring them up to the same version already included in Windows 7 and Windows Server 2008 R2.
• Windows PowerShell Remoting does not require any specific configuration to let you connect to a remote computer, but it does require a configuration step to allow connections from remote computers.
• Once you’ve decided to enable remoting, Windows PowerShell makes this a snap (after informing you of the impact).
• Simply call Enable-Ps Remoting from an elevated shell. The solution demonstrates this approach. To bypass any user prompts or confirmation, also specify the -Force flag.

Enable remoting on a remote machine:
• Remotely enabling Windows PowerShell Remoting offers many unique challenges.
• Although you can certainly use Remote Desktop to connect to the system (and then essentially enable it locally), Remote Desktop does not lend itself to automation.
• Instead, you can leverage another remoting technology that does lend itself to automation:
• Windows Management Instrumentation (WMI).
• WMI is enabled on most domain machines, but it offers only a minor facility for remote command execution: the Create() method of the Win32_Process.

Enable Remote Desktop on a Computer:
• Remote Desktop is the de facto interactive management protocol but can be difficult to enable automatically.
• Fortunately, its configuration settings come from the Windows Registry, so you can use Windows PowerShell’s registry provider to enable it.
• To disable Remote Desktop, set the fDenyTSConnections property to 1.
• To enable Remote Desktop on a remote computer, use Windows PowerShell Remoting to change the registry properties, or remotely manage the registry settings directly.
• Set the fDenyTSConnections property of the remote desktop registry key to 0:
$regkey = "HKLM:\SYSTEM CurrentControlSet Control Terminal Server"
Set-ItemProperty §regkey fDenyISConnections 0


Create New Registry Keys:
• As the configuration store for the vast majority of applications, the registry plays a central role in system administration.
• It is also generally hard to manage.
• Although command-line tools (such as reg.exe) exist to help you work with the registry, their interfaces are usually inconsistent and confusing.
• The Registry Editor graphical user interface is easy to use, but it does not support scripted administration.
• Windows PowerShell tackles this problem by exposing the Windows Registry as a navigation provider: a data source that you navigate and manage in exactly the same way that you work with the filesystem.
• Windows PowerShell lets you navigate the Windows Registry in exactly the same way that you navigate the filesystem, certificate drives, and other navigation-based providers.
• Like these other providers, the registry provider supports the Set-Location cmdlet (with the standard aliases of sl, cd, and chdir), Push-Location (with the standard alias pushd), Pop-Location (with the standard alias popd), and more.
• Use the Set-Location cmdlet to navigate the registry, just as you would navigate the filesystem.
• When working in the registry, you might sometimes want to chain a set of related changes and be sure that they all get applied as a single unit.
• These are goals known as atomicity and consistency: the desire to avoid situations where an error during any step of the operation could cause an inconsistent system state if the other operations are not also successful.
• To support this type of management task, Windows PowerShell supports a change management strategy known as transactions.
• On Windows Vista and later, Windows PowerShell’s registry provider fully supports transactions.
• When you start a transaction, any commands in that transaction are virtual and don’t actually apply to the system until you complete the transaction.
• Within the context of the transaction, though, each participating command sees the system as though the state really had changed.
• Once you complete a transaction, changes are applied as a single unit.
• Some systems that support transactions (such as databases) put locks on any resources that are being changed by a transaction.
• If another user tries to modify the locked resources, the user gets an error message.
• This is not supported in the Windows Registry.
• If something alters a resource that your transaction depends on, the changes contained in your transaction will be abandoned, and you will receive an error message when you try to complete that transaction.


Active Directory Management:
• Every IT Administrator faces a number of Active Directory Management challenges which includes managing user accounts in Active Directory almost every day.
• Configuring user properties manually is extremely time-consuming, tiresome, and error-prone, especially in a large, complex Windows network.
• Active Directory administrators and IT managers mostly have to perform repetitive and mundane tasks which often end up eroding into their productive or free times.
• Moreover, accomplishing these tasks using the native tools or Windows PowerShell also demands a deeper knowledge in Active Directory Management, and related technologies are not trouble or complexity free by any means.
• Software that can automate these cumbersome tasks, simplify AD management and provide exhaustive reports on tasks done and their status, is the need of the hour.
• AD Manager Plus is one simple, hassle-free web-based solution for all Active Directory Management challenges, safe with secure authentication and performs all actions with just mouse clicks.
• This Active Directory management tool allows administrators to design templates to manage all Active Directory account creation and modification processes.
• Moreover, through its web-interface, this AD management software offers administrators an absolute control over their Active Directory environment.
• Keep in mind that in order to use these Windows PowerShell scripts, you must import the module for interacting with AD — the Active Directory Module for Microsoft Windows PowerShell.
• This module was introduced in Windows Server 2008 R2 and is enabled by default in Windows Server 2012 and later. You can get the full list of AD module cmdlets by running the following command: Get-Command -Module ActiveDirectory -Name "*Group*"
• To create an AD group, use the New- ADGroup cmdlet. You can get its syntax by running the following command: Get-Command New-ADGroup -Syntax
• The system will ask you to specify the “GroupScope” parameter, and then it will create a new group.
However, this group will have default values, such as:
-It will be created in the default LDAP container called “Users”.
-It will have the “Security” group type.
-The members, member of, description, email and notes fields will all be blank.


WMI (Windows Management Instrumentation):
WMI is a Microsoft technology that provides a standardized way for Windows operating systems to expose management information.
It is Microsoft's implementation of the Web-Based Enterprise Management (WBEM) standard.
WMI has been available on Windows operating systems since Windows NT 4.0.

CIM (Common Information Model):
CIM is a specification defined by the Distributed Management Task Force (DMTF) that describes computer hardware and software components.
It is part of a larger systems-management framework called Web-Based Enterprise Management (WBEM).
CIM is based on open, cross-platform standards.

WMI and CIM History:
WMI:
WMI has been part of Windows operating systems since Windows NT 4.0.
It is Microsoft's long-standing approach to management information.
CIM:
CIM is a newer technology that is based on open, cross-platform standards.
It is part of the Web-Based Enterprise Management (WBEM) framework.

WMI and CIM Characteristics:
WMI:
-Microsoft's implementation of WBEM.
-Based on preliminary standards and proprietary technology.
-Has been available on Windows operating systems since Windows NT 4.0.
-Uses DCOM for ad-hoc connections.
CIM:
-Based on open, cross-platform standards.
-Forms part of the larger WBEM framework.
-Supports various types of connections, including DCOM and WS-MAN.

WMI and CIM Cmdlets:
WMI Cmdlets:
-Used for ad-hoc connections over DCOM.
-Communicate with the WMI service.
-Necessary when PowerShell remoting is not enabled.
-Considered legacy, and Microsoft is deprecating them in favor of CIM cmdlets.
-Examples: Get-WmiObject, Set-WmiInstance, Invoke-WmiMethod, etc.
CIM Cmdlets:
-Provide cross-platform and cross-version capabilities.
-Support local and remote connections using DCOM or WS-MAN.
-Leaner, meaner, and more modern compared to WMI commands.
-Recommended for use over WMI commands.
-Examples: Get-CimInstance, Set-CimInstance, Invoke-CimMethod, etc.

WMI and CIM Commands:
WMI Commands:
-Support only ad-hoc connections over DCOM.
-Communicate with the WMI service.
-Used when PowerShell remoting is not enabled or in legacy environments.
CIM Commands:
-Support local connections using DCOM.
-Support ad-hoc connections to remote computers using WS-MAN.
-Support session-based connections to remote computers using DCOM or WS-MAN.
-Modern and recommended for use.

WMI vs CIM:
-WMI is Microsoft's specific implementation of the WBEM standard.
-CIM is a broader specification that is not tied to a specific vendor and is based on open standards.
-WMI commands are specific to Microsoft and may not be as cross-platform as CIM commands.
-CIM is more modern, supports open standards, and is recommended for use over WMI.

WMI Commands vs CIM Commands:
-WMI commands are legacy and are being deprecated by Microsoft.
-CIM commands are more modern, support cross-platform capabilities, and are recommended for use.
-WMI commands are necessary only in specific cases, such as when PowerShell remoting is not enabled or in legacy environments.

There are 3 types of connections possible with CIM:
-Connection to local Computer using DCOM.
-Ad hoc connection to a remote computer using WS-MAN
-Session-based connection to a remote computer using DCOM or WS-MAN

Use CIM commands in two ways:
• The first way requires the remote computer to have WinRM installed and enabled.
• The second way to use CIM commands is to use the earlier WMI technology for CIM commands.

Windows PowerShell WS-Man remoting brings these possibilities:
• HTTP/HTTPS transport and XML serialised data streams make the remote access extremely firewall-friendly.
• WS-Man remoting is stateless, which means faster performance than with the older DCOM/RPC methods.
• Remote computers are queried in parallel, in what Microsoft calls a "fan out" remote management scenario.

Querying WMI:
• One of the main tools of Windows Management Instrumentation (WMI) is the ability to query the WMI repository for class and instance information.
• For example, you can request that WMI return all the objects representing shut-down events from your desktop system.
• You can also retrieve class, instance, or schema data. The following table lists the different types of queries you can make.
Invoking a Synchronous Query:
• Describes how to maintain a link with WMI throughout the query process.
• Synchronous queries are good for small queries or queries to a local system.
Invoking an Asynchronous Query:
• Describes how to set up a separate process to receive queries.
• Asynchronous queries are more complex and provide a lower level of security, but generally, improve system performance.

Powershell array:
PowerShell arrays are a data structure that allows you to store a collection of items in a single variable. The items in an array can be of the same type or different types. An item can be a string, an integer, an object, or even another array. Each element or value in an array has an index.
Arrays are a fundamental part of PowerShell, or any programming language because they allow you to store and structure a collection of items into a single variable. We can then use the array to perform a wide range of tasks on each of the items in the array.
To create an array, you use the New-Object cmdlet. The syntax is:
New-Object -TypeName <type> -ArgumentList <list of arguments>
For example, to create an array of 10 integers, you would use the following command:
New-Object -TypeName Integer -ArgumentList 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
To access an element in an array, you use the index. The index starts at 0, so the first element in an array is at index 0. For example, to access the first element in the array above, you would use the following command:
$array
To iterate over an array, you can use a for loop. For example, the following code will print all of the elements in the array above:
For ($i = 0; $i -lt $array.Count; $i++) {
Write-Host $array[$i]
}
Arrays can be used to store a lot of data, and they can be very useful for performing tasks on large amounts of data.

Jagged and multidimensional arrays:
• Jagged and multidimensional arrays are useful for holding lists of lists and arrays of arrays.
• Jagged arrays are arrays of arrays, where each array has only as many elements as it needs.
• A nonjagged array is more like a grid or matrix, where every array needs to be the same size.
• Jagged arrays are much easier to work with (and use less memory), but nonjagged multidimensional arrays are sometimes useful for dealing with large grids of data.
• Since a jagged array is an array of arrays, creating an item in a jagged array follows the same rules as creating an item in a regular array.
• If any of the arrays are single-element arrays, use the unary comma operator.
• To create an array of arrays (a jagged array), use the @() array syntax: $jagged = @((1,2,3,4),(5,6,7,8))
• To create a (nonjagged) multidimensional array, use the New-Object cmdlet: $multidimensional = New-Object "int32[,]" 2,4

Access Elements of an Array in powershell:
To access elements of an array in PowerShell, you can use the index. The index of the array usually starts at 0, so to access the first element you must use the index.
For example, if you have an array called $array that contains the values 1,22,33,66,88,99, then you can access the first element of the array by typing the following command on the PowerShell:
$array[0]
This will return the value 1.

Sort an array or list of items in powershell:
To sort an array or list of items in PowerShell, you can use the Sort-Object cmdlet. The syntax is:
Sort-Object [-Property <property1> [<property2> ...]] [-Descending] [-Unique]
The -Property parameter specifies the property or properties you want to sort by. The -Descending switch specifies whether you want to sort the data in descending order. The -Unique switch removes duplicate items from the result.
For example, to sort the items in the array $array by the Name property in ascending order, you would use the following command:
$array | Sort-Object -Property Name
To sort the items in the array $array by the Name property in descending order, you would use the following command:
$array | Sort-Object -Property Name -Descending
To sort the items in the array $array by the Name property and remove duplicate items, you would use the following command:
$array | Sort-Object -Property Name -Unique

Combine two arrays:
• To combine two arrays, Windows PowerShell creates a new array large enough to hold the contents of both arrays and then copies both arrays into the destination array.
• If you plan to add and remove data from an array frequently, the System.Collections.ArrayList class provides a more dynamic alternative.
• To combine Windows PowerShell arrays, use the addition operator (+).

Hashtables in PowerShell:
In PowerShell, a hashtable is a collection of key-value pairs, where each key is unique within the hashtable. It allows you to store and retrieve values based on their associated keys, providing a convenient way to organize and access data. Hashtables are created using the @{} syntax in PowerShell and are often used for tasks such as configuration settings, mapping, or quick data lookups.
# Example of a Hashtable
$myHashtable = @{
    Key1 = 'Value1'
    Key2 = 'Value2'
    Key3 = 'Value3'
    # ... additional key-value pairs
}
Sorting a Hashtable by Key or Value:
To sort a hashtable in PowerShell, you can use the GetEnumerator() method to retrieve the key-value pairs and then use the Sort-Object cmdlet to sort them based on either the keys or values.
Sorting by Key:
$sortedHashtableByKey = $myHashtable.GetEnumerator() | Sort-Object Key
# Displaying the sorted hashtable
$sortedHashtableByKey | ForEach-Object { Write-Output "$($_.Key): $($_.Value)" }
Sorting by Value:
$sortedHashtableByValue = $myHashtable.GetEnumerator() | Sort-Object Value
# Displaying the sorted hashtable
$sortedHashtableByValue | ForEach-Object { Write-Output "$($_.Key): $($_.Value)" }

The different ways that PowerShell uses to ‘Select’:
a. Select * from
b. Select-String
c. Select Object

Windows PowerShell Jobs:
Overview:
Windows PowerShell jobs enable the execution of commands in the background, allowing concurrent task handling.
Initiate a new job with the Start-Job cmdlet, encapsulating the command in a script block. Jobs are sequentially named (e.g., Job1, Job2).
Jobs receive sequential IDs, starting with 1, and can be referenced by either ID or name (e.g., Get-Job -Id 3).
Job Management:
Upon completion, retrieve job results using the Receive-Job cmdlet. Use a variable or include the -Keep switch to retain data.
Best practice: use Remove-Job to clear completed jobs, avoiding confusion between active, completed, and pending jobs.
Removed jobs are inaccessible; attempting retrieval triggers an error with Get-Job.
Naming Conventions:
Assign meaningful names to jobs (e.g., getProc for a job returning process objects). Contextual names enhance clarity.
Utilize wildcard characters for flexibility in typing lengthy job names.
Working with Job Results:
When receiving job output, store it in a variable for further use with other PowerShell cmdlets.
Note: retrieved objects are deserialized; use Get-Member (gm) to inspect available methods.
Cmdlets and Noun "Job":
List all cmdlets with the noun "job" using Get-Command -Noun job | Select-Object Name.
Keep in mind that data retrieved with Receive-Job is consumed, and attempting a second retrieval will result in an error.
Example Cleanup:
After using Receive-Job, handle any errors using the job object stored in a variable (e.g., $rtn) or the Get-Net6to4Configuration job.
Conclusion:
Windows PowerShell jobs offer parallel execution, efficient multitasking, and streamlined job management.
Adopting proper naming conventions, utilizing wildcard characters, and managing job remnants enhance script readability and maintainability.

Starting and managing jobs in powershell:
Start-Job: Starts a background job on the local or remote computer.
Get-Job: Retrieves information about running background jobs.
Receive-Job: Outputs the results of a completed or stopped job.
Wait-Job: Waits for a specific job to finish before continuing.

Creating a scheduled job in powershell:
New-JobTrigger: Creates a scheduled trigger for a job.
Register-ScheduledJob: Registers a job with the Windows Task Scheduler.
Use Get-ScheduledJob, Enable-ScheduledJob, Disable-ScheduledJob, and Remove-ScheduledJob for managing scheduled jobs.
Trigger types: Time-based, event-based (e.g., logon), manual trigger.

NTFS Persmissions:
• There are both basic and advanced NTFS permissions. You can set each of the permissions to “Allow” or “Deny”. Here are the basic permissions:
• Full Control: Users can modify, add, move and delete files and directories, as well as their associated properties. In addition, users can change permissions settings for all files and subdirectories.
• Modify: Users can view and modify files and file properties, including deleting and adding files to a directory or file properties to a file.
• Read and Execute: Users can run executable files, including script.
• Read: Users can view files, file properties and directories.
• Write: Users can write to a file and add files to directories

Configuring NTFS permissions: 
Many organisations with a Microsoft Windows environment rely on NTFS as the main file system for their storage devices that contain sensitive data. It is the easiest way for users to work with files. In order to implement a least-privilege model, which is a best practice for system security, IT security specialists and system administrators configure NTFS access control lists (ACLs) by adding access control entries (ACEs) on NTFS file servers.
NTFS permissions can be either explicit or inherited. Explicit permissions are permissions that are configured individually, while inherited permissions are inherited from the parent folder. The hierarchy for permissions is as follows:
• Explicit Deny
• Explicit Allow
• Inherited Deny
• Inherited Allow
Now, that we know NTFS permissions are, let’s explore how to manage them.
The first PowerShell cmdlet used to manage file and folder permissions is “get-acl”; It lists all object permissions.
get-acl C:\Users\niks\Desktop\Crack | f1
-Copy File and Folder Permissions:
To copy permissions, a user must own both the source and target folders.
The following command will copy the permissions from the “Crack” folder to the “niks” folder:
get-acl C:lUsers\niks\Desktop\Crack | Set-Acl C:\Users\niks\Desktop\niks
get-acl C:\Users\niks\Desktop\niks | f1
-Set File and Folder Permissions:
• The PowerShell “set-acl” cmdlet is used to change the security descriptor of a specified item, such as a file, folder or a registry key;
• In other words, it is used to modify file or folder permissions.
• The following script sets the “FullControl” permission to “Allow” for the user “DESKTOP-9QLDK2P\niks” to the folder “niks”:
PS C: \WINDOWS\system32> $acl = get-acl C: \Users\niks\Desktop\Crack
PS C: \WINDOWS\system32> $AccessRule = New-Object System.Security.AccessControl.FileSystemAccessRule("DESKTOP-9QLDK2P\niks", "FullControl", "Deny")
PS C: \WINDOWS\system32> $acl.SetAccessRule($AccessRule)
PS C: \WINDOWS\system32> $acl | Set-Acl C: \Users\niks\Desktop\Crack
PS C: \WINDOWS\system32> get-acl C:\Users\niks\Desktop\Crack | f1

Profiles in PowerShell:
In Windows PowerShell ISE (Integrated Scripting Environment), profiles are scripts that automatically run when the PowerShell ISE starts. These scripts can be used to customize the environment, load specific modules, define functions, or perform other tasks to set up your PowerShell environment according to your preferences.
PowerShell profiles are powerful tools that allow you to customize your environment and automate tasks every time you start a new PowerShell session. 
They are essentially scripts that run automatically when PowerShell launches, providing a way to:
Set variables and aliases: You can define your commonly used variables and aliases in your profile, making them available in every session without needing to redefine them each time.
Import modules: Frequently used modules can be imported in your profile, saving you the time of importing them manually in each session.
Change the look and feel: You can customize the appearance of your console, including font size, colors, and prompt settings.
Load scripts: You can load scripts that automate repetitive tasks or configure your environment automatically.
There are six different types of profiles in PowerShell:
CurrentUserCurrentHost: This profile is specific to the current user and current host. It is the most commonly used profile. $profile.CurrentUserCurrentHost.
AllUsersCurrentHost: This profile applies to all users on the current host. $profile.AllUsersCurrentHost.
CurrentUserAllHosts: This profile applies to the current user on all hosts. $profile.CurrentUserAllHosts.
AllUsersAllHosts: This profile applies to all users on all hosts. $profile.AllUsersAllHosts.
Microsoft.PowerShell: This profile is used specifically by the PowerShell engine and should not be modified manually.
Microsoft.PowerShellISE: This profile applies to the PowerShell ISE and is used to customize the ISE environment.
Here are some of the benefits of using profiles:
Increased efficiency: By automating tasks and making commonly used elements readily available, profiles can save you time and improve your workflow.
Consistency: Profiles ensure that your environment is always configured the way you want it, regardless of which machine you are using.
Reduced errors: By having your environment preconfigured, you can avoid typos and other errors that can occur when setting up your environment manually.

3 Methods to Validate IP Addresses in PowerShell:
1. Splitting the IP Address Octets and Typecasting to [Byte]:
Split the string by "." into four octets.
Check if the length is exactly four.
For each octet, convert it to a byte using [byte] type cast and validate if it's between 0 and 255.
If all octets are valid, the IP address is valid.
2. Using a Regular Expression:
Use a regular expression like ^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$ to match valid IP address format.
This regex ensures each octet has 1 to 3 digits and is separated by dots.
If the string matches the regex, the IP address is valid.
3. Type Cast to [System.Net.IPAddress] Class:
Use the [System.Net.IPAddress].TryParse() method.
This method attempts to convert the string to a valid IP address object.
If the conversion is successful, the IP address is valid.

Disable or Enable Permissions Inheritance:
• To manage an inheritance, we use the “SetAccessRuleProtection” method. It has two parameters:
• The first parameter is responsible for blocking inheritance from the parent folder.
• It has two states: “$true” and “$false”.
• The second parameter determines whether the current inherited permissions are retained or removed.
• It has the same two states: “$true” and “$false”.
• Let us disable inheritance for the “Sales” folder and delete all inherited permissions as well:

Location of PowerShell in SharePoint:
PowerShell modules related to SharePoint are typically found in the SharePoint Management Shell.
The executable is often located in the SharePoint Hive folder, e.g., C:\Program Files\Common Files\Microsoft Shared\Web Server Extensions\16\CONFIG\POWERSHELL\Registration\SharePoint.ps1

Differences between $Other_Language and PowerShell:
Syntax: PowerShell uses a verb-noun syntax for cmdlets (Get-Process), while other languages may have different syntax conventions.
Object-Oriented: PowerShell treats data as objects, providing rich manipulation capabilities, whereas some languages may use different data structures.

Difference between Concerto-CSV and Export-CSV Commands:
There is no recognized command called "Concerto-CSV" in PowerShell.
Export-CSV is a valid cmdlet that exports data to a CSV file.

Checking Default Path for PowerShell Modules:
Use $env:PSModulePath to check the default paths for PowerShell modules.
Example: $env:PSModulePath -split ';'

Updating Help on Servers without Internet Access:
Use the Update-Help cmdlet with the -SourcePath parameter.
Example: Update-Help -SourcePath "C:\Path\To\HelpFiles"

Two Methods for Pipeline Input:
ByValue: Objects are passed down the pipeline by value.
ByPropertyName: Objects are passed down the pipeline based on matching property names.

How does Remoting Work:
Remoting in PowerShell uses protocols like WS-Man or SSH to establish a secure connection between computers.
It involves creating a session on the remote machine and executing commands or scripts within that session.

Is PowerShell Remoting Secure:
Yes, PowerShell remoting is designed with security in mind.
It uses encryption and authentication mechanisms to protect data during transmission.
Requires appropriate permissions and configuration for secure operation.

Do All Remote Commands Require PowerShell Remoting:
No, not all remote commands require PowerShell remoting.
Some commands, like those using WMI or CIM, can interact with remote systems without explicitly enabling PowerShell remoting.

Running a Command on a Remote Computer:
Use Invoke-Command to run commands on a remote computer.
Example: Invoke-Command -ComputerName "RemoteComputer" -ScriptBlock { Get-Process }

"Telnet Into" a Remote Computer:
PowerShell remoting can provide a similar experience.
Example: Enter-PSSession -ComputerName "RemoteComputer"

Creating a Persistent Connection:
Use New-PSSession to create a persistent session.
Example: $session = New-PSSession -ComputerName "RemoteComputer"

Running Commands on Multiple Computers:
Use workflows, jobs, or parallel scripting to run commands on multiple computers simultaneously.
Examples: Invoke-Command -ComputerName "Computer1", "Computer2" -ScriptBlock { ... }

Throttling on Remote Commands:
Throttling limits the number of simultaneous remote connections or commands.
Helps prevent resource exhaustion on the local or remote systems.

Output of Remote Commands vs. Local Output:
Output from remote commands is serialized and sent back to the local machine.
The format may differ from local output, especially when dealing with complex objects or collections.

Fan-In and Fan-Out Configurations:
Fan-In: Refers to the scenario where multiple clients or sources send data to a central point.
Fan-Out: Refers to the scenario where data is distributed from a central source to multiple destinations.
In PowerShell remoting, fan-out occurs when commands are executed on multiple remote machines simultaneously.

PowerShell Scripts for SharePoint Deployment:
PowerShell scripts, known as PowerShell SharePoint Deployment Scripts, can automate deployment tasks in SharePoint.
Cmdlets: SharePoint Management Shell provides specific cmdlets for SharePoint component deployment.
Script Examples: Scripts can handle tasks like deploying solutions, activating features, and updating configurations.

Comparison Operators in PowerShell:
Common Operators: Include -eq (equal), -ne (not equal), -lt (less than), -gt (greater than), etc.
Object Comparison: PowerShell's operators can compare not only scalar values but also complex objects.
Case-Insensitive: Many operators have case-insensitive variants (e.g., -ieq, -ine).
Chaining: Multiple operators can be chained for complex comparisons.

Mapping Network Drive in PowerShell:
New-PSDrive Cmdlet: Used to map a network drive.
Example: New-PSDrive -Name "Z" -PSProvider FileSystem -Root "\\server\share" -Persist $true
Persist Parameter: Ensures the drive persists across sessions.

Get-Service Status Function:
Cmdlet: Get-Service retrieves information about services on a computer.
Status Parameter: The -Status parameter filters services based on their status (e.g., Get-Service -Status Running).

$input Variable:
Input Handling: $input is an automatic variable in PowerShell that represents input passed to a script or function.
Enumerator: Acts as an enumerator for input data, useful in processing pipeline input.
Read-Host Replacement: Can be used as an alternative to Read-Host for interactive input.

Identifying 32-bit or 64-bit in PowerShell:
[Environment] Class: Use [Environment]::Is64BitOperatingSystem to check if the operating system is 64-bit.
True/False: Returns True if the OS is 64-bit, False otherwise.

Finding SQL Services in PowerShell:
Get-Service Cmdlet: Use Get-Service with filters or conditional statements to find SQL services.
Example: Get-Service | Where-Object { $_.DisplayName -like 'SQL*' }

Code to Locate Installed Applications:
Registry Access: Use the registry to access uninstall information.
Example: $uninstallKeys = Get-ItemProperty -Path "HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" | Select-Object DisplayName, UninstallString

PowerShell Cmdlets and commands:
1.Get-Location (alias: pwd):
Description: Displays the current working directory.
Usage Example: Get-Location
2.Get-ChildItem (alias: dir):
Description: Lists the contents of a directory.
Usage Example: Get-ChildItem
3.attrib +h dir:
Description: Adds the hidden attribute to a directory.
Usage Example: attrib +h C:\ExampleDirectory
4.attrib -h dir:
Description: Removes the hidden attribute from a directory.
Usage Example: attrib -h C:\ExampleDirectory
5.Get-Process (alias: Tasklist):
Description: Displays a list of currently running processes.
Usage Example: Get-Process
6.Stop-Process (alias: Taskkill):
Description: Terminates a process with the specified Process ID (PID).
Usage Example: Stop-Process -Id 123
7.Get-WmiObject Win32_Processor (alias: cpu):
Description: Retrieves information about the CPU.
Usage Example: Get-WmiObject Win32_Processor
8.diskpart:
Description: Opens the DiskPart command-line tool for disk management.
Usage Example: diskpart
9.Get-Disk (alias: list disk):
Description: Lists all available disks.
Usage Example: Get-Disk
10.Get-Disk (alias: select disk 0):
Description: Selects a specific disk for further operations.
Usage Example: Select-Disk -Number 0
11.chkdsk:
Description: Checks a disk for errors and attempts to fix them.
Usage Example: chkdsk C:
12.Get-Command -Noun S*:
Description: Retrieves all cmdlets with a noun starting with 'S'.
Usage Example: Get-Command -Noun S*
13.Get-Command -Noun service:
Description: Retrieves cmdlets with the noun 'service'.
Usage Example: Get-Command -Noun service
14.Get-Service:
Description: Lists all services on the computer.
Usage Example: Get-Service
15.Get-Help Get-Service (example):
Description: Displays help information for the Get-Service cmdlet.
Usage Example: Get-Help Get-Service -Example
16.Get-Help Get-Service -Online:
Description: Opens the online documentation for the Get-Service cmdlet in a web browser.
Usage Example: Get-Help Get-Service -Online
17.Get-Alias:
Description: Lists all defined aliases in the current session.
Usage Example: Get-Alias
18.Get-Alias cls:
Description: Retrieves the alias for the 'cls'(clear screen alias).
Usage Example: Get-Alias cls
19.Get-History:
Description: Displays the command history for the current session.
Usage Example: Get-History
20.Get-Process:
Description: Lists all currently running processes.
Usage Example: Get-Process
21.Get-Process -Name MicrosoftEdge:
Description: Retrieves information about the 'MicrosoftEdge' process.
Usage Example: Get-Process -Name MicrosoftEdge
22.Get-Process -Name MicrosoftEdge | Get-Member:
Description: Displays the members (properties and methods) of the 'MicrosoftEdge' process object.
Usage Example: Get-Process -Name MicrosoftEdge | Get-Member
23.Get-Process -Name MicrosoftEdge | Select-Object *:
Description: Selects and displays all properties of the 'MicrosoftEdge' process.
Usage Example: Get-Process -Name MicrosoftEdge | Select-Object *

Command-Name and Description:
Syntax for viewing the methods and properties we can pipe our output to Get-Member by: Get-Process | Get-Member
Add-content: This cmdlet adds the content to the specified file.
Add-Computer: This cmdlet adds the local computer to a domain or workgroup.
Add-History: This cmdlet is used to add the command in the history.
Add-jobTrigger: This cmdlet adds the job triggers to the scheduled jobs.
Add-member: The cmdlet adds the custom methods or properties to an instance of a PowerShell object.
Add-type: This cmdlet adds a Microsoft .NET framework class to a Windows PowerShell session.
Clear-Content: This cmdlet deletes the content of a file, but not delete that file.
Clear-History: This cmdlet deletes the entries from the command history.
Clear-Item: This cmdlet clears the value of item or variable, but not clear that item or a variable.
Clear-ItemProperty: This cmdlet clears the value of a property but not delete that property.
Clear-Variable: This cmdlet deletes the value of a variable.
Clear-Host: This cmdlet clears the display of the host program.
Copy-ItemProperty: This cmdlet copies a value and property from a specified location to another location.
Copy-Item: This cmdlet copies an item from one location to another.
Complete-Transaction: This cmdlet commits the active transaction.
Compare-object: This cmdlet compares two sets of objects.
Disable-PSBreakpoint: This Cmdlet disables the breakpoint in the current console.
Enable-PSBreakpoint: This Cmdlet enables the breakpoint in the current console.
Find-package: This cmdlet finds the software packages in the available packages sources.
Find-script: This cmdlet is used to find a script
ForEach-Object: This cmdlet performs an operation on each item in a collection of input objects.
Get-Alias: This cmdlet gets the aliases for the current session.
Get-childItem: This cmdlet gets the item and the child items in one or more specified locations.
Get-Command: This cmdlet is used to get all commands.
Get-Content: This cmdlet gets the content of the file at the specified location.
Get-Date: This cmdlet is used to get the current date and time.
Get-ExecutionPolicy: This cmdlet gets the execution policy for the current session.
Get-Help: This cmdlet displays information about PowerShell commands and concepts.
Get-History: This cmdlet displays a list of commands which are entered during the current session.
Get-host: This cmdlet gets an object which represents the current host program.
Get-InstalledScript: This cmdlet gets a script which is installed for the current user.
Get-Item: This cmdlet gets the item or a file at a particular location.
Get-ItemProperty: This cmdlet gets the properties of a particular item.
Get-Location: This cmdlet displays the current working location.
Get-PSBreakpoint: This cmdlet gets the breakpoint which is set in the current session.
Get-Package: This cmdlet displays the list of all installed packages by using the package management.
Get-Process: This cmdlet gets the processes which are running on local or remote computers.
Get-Service: This cmdlet gets the services on local or remote computers.
Get-Transaction: This cmdlet gets the currently active transaction.
Get-Variable: This cmdlet gets the variable in the current console.
Install-package: This cmdlet is used to install one or more software packages.
Install-script: This cmdlet is used to install a script.
Invoke-commands: This cmdlet executes commands on local and remote computers.
Move-Item: This cmdlet is used to move an item from one location to another.
Move-ItemProperty: This cmdlet is used to move the property of an item from one location to another.
New-alias: This cmdlet creates a new alias.
New-Item: This cmdlet creates a new item.
New-ItemProperty: This cmdlet creates a new property for an item and sets its value.
New-Service: This cmdlet creates a new Window service.
New-variable: This cmdlet creates a new variable.
Read-Host: This cmdlet reads a line of inputs from the console.
Remove-computer: This cmdlet removes a local computer from its domain.
Remove-Item: This cmdlet deletes the particular item.
Remove-ItemProperty: This cmdlet deletes the property & its value from an item.
Remove-job: This cmdlet removes the background job of Windows PowerShell.
Remove-PSBreakpoint: This cmdlet deletes the breakpoint from the current console.
Remove-variable: This cmdlet deletes a variable with its value.
Rename-computer: This cmdlet is used to rename a computer.
Restart-Service: This cmdlet stops and starts one or more services.
Restart-computer: This cmdlet is used to restart the Windows operating system on local and remote computers.
Resume-job: This cmdlet is used to restart a suspended job.
Save-Help: It is used to download and save the newest help files to a file system directory.
Save-packages: This cmdlet is used to save the packages to the local computer without installing them.
Save-Script: This cmdlet is used to save a script.
Select-string: This cmdlet is used to find the text in string or files.
Send-MailMessage: This cmdlet is used to send an e-mail message.
Set-Alias: This cmdlet creates or changes the alias for a cmdlet in the current Windows PowerShell.
Set-content: This cmdlet writes the content in a file.
Set-Date: This cmdlet changes the time of the system.
Set-Item: This cmdlet changes the value of an item to the value specified in the command.
Set-ItemProperty: This cmdlet change or creates the value of the property of an item.
Set-Location: This cmdlet is used to set the current working location to a particular location.
Set-PSBreakpoint: This cmdlet sets a breakpoint on a command, line or a variable.
Set-ScheduledJob: This cmdlet changes the scheduled Job.
Set-Service: This cmdlet stops, start and suspend services, and changes its properties.
Set-variable: This cmdlet sets the value of the variable.
Show-command: This cmdlet creates the Windows PowerShell commands in a graphical command Window.
Sort-Object: This cmdlet sorts the object by the property value.
Start-Job: This cmdlet starts a background job of Windows PowerShell.
Start-Process: This cmdlet starts on or more process on a local computer.
Start-services: This cmdlet starts one or more services which are stopped.
Start-transaction: This cmdlet starts a transaction.
Stop-Computer: This cmdlet shut down the local and remote computers.
Stop-Job: This cmdlet stops a background job of Windows PowerShell.
Stop-Process: This cmdlet stops one or more processes.
Stop-Services: This cmdlet stops one or more running services.
Suspend-jobs: This cmdlet temporarily stops the workflow jobs.
Suspend-Service: This cmdlet suspends or pauses one or more running services.
Undo-transaction: This cmdlet rollbacks the active transaction.
Uninstall-module: This cmdlet is used to uninstall a module.
Uninstall-Package: This cmdlet uninstalls one or more packages of software.
Unregister-ScheduledJob: This cmdlet deletes the scheduled jobs on the local computer
Update-Help: This cmdlet is used to download and installs the newest help files on the computer.
Write-Output: This cmdlet sends the particular object down the pipeline to the next command.

Parameters:
-ArgumentList: The -ArgumentList parameter is used to specify an array of arguments. An alias for this parameter is Args. Wildcard characters are not supported.
-Verb: The -Verb parameter is used to specify an array of command verbs. Wildcard characters are accepted.
-Noun: The -Noun parameter is used to specify an array of command nouns. Wildcard characters are accepted.
-Module: The -Module parameter is used to specify an array of modules. It gets those commands which come from the specified modules. The -Module parameter takes the string values, but the value of it can also be a PSModuleInfo object

Windows PowerShell Scripting:
Definition: Windows PowerShell scripting involves creating sequences of commands (scripts) written in the PowerShell language to automate and perform tasks on Windows systems.
Purpose: Automates repetitive tasks, enhances system management, and enables efficient administration.
Language: PowerShell scripting uses cmdlets, functions, and scripts to execute commands.

Cmdlets:
Definition: Cmdlets (Command-lets) are lightweight commands in PowerShell.
Verb-Noun Naming: Follow a Verb-Noun naming convention (e.g., Get-Process, Stop-Service).
Built-in: PowerShell includes numerous built-in cmdlets for various tasks.
Extensibility: Users can create custom cmdlets to extend functionality.
