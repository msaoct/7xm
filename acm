PowerShell:
- PowerShell is a task automation and configuration management framework from Microsoft, consisting of a command-line shell and associated scripting language.
- Initially a Windows component only, known as Windows PowerShell, it was made open-source and cross-platform on 18 August 2016 with the introduction of PowerShell Core.
- The former is built on .NET Framework while the latter on .NET Core.
- In PowerShell, administrative tasks are generally performed by cmdlets (pronounced command-lets), which are specialised .NET classes implementing a particular operation.
- Third-party developers can develop their own cmdlets and add them to PowerShell.
- Sets of cmdlets may be combined into scripts.

PowerShell Background:
Every version of Microsoft Windows for personal computers has included a command line interpreter (CLI) for managing the operating system. Its predecessor, MS-DOS, relied exclusively on a CLI.
These are COMMAND.COM in MS-DOS and Windows 9x, and cmd.exe in the Windows NT family of operating systems.
Microsoft attempted to introduce the Windows Script Host in 1998 with Windows 98, and its command-line based host: cscript.exe.
Different versions of Windows provided various special-purpose command-line interpreters (such as netsh and WMIC) with their own command sets, but they were not interoperable.
By 2002 Microsoft had started to develop a new approach to command line management, including a CLI called Monad (also known as Microsoft Shell or MSH).
Microsoft published the first Monad public beta release on June 17, 2005, Beta 2 on September 11, 2005, and Beta 3 on January 10, 2006.
On April 25, 2006, Microsoft formally announced that Monad had been renamed Windows PowerShell.
PowerShell v2.0 was completed and released to manufacturing in August 2009, as an integral part of Windows 7 and Windows Server 2008 R2.
Versions of PowerShell for Windows XP, Windows Server 2003, Windows Vista and Windows Server 2008 were released in October 2009.
On 18 August 2016, Microsoft announced that they had made PowerShell open-source and cross-platform with support for Windows, macOS, CentOS and Ubuntu.

PowerShell Design:
PowerShell was designed by - A. Jeffrey Snover, Bruce Payette, James Truher.
PowerShell's developers based the core grammar of the tool on that of the POSIX 1003.2 Korn shell.
Windows PowerShell can execute four kinds of named commands:
• cmdlets (.NET Framework programmes designed to interact with PowerShell).
• PowerShell scripts (files suffixed by .ps1).
• PowerShell functions.
• Standalone executable programmes.

Open Powershell:
Run a search for PowerShell on your computer.
You probably have several different options, like “PowerShell,” “PowerShell ISE,” and “PowerShell (x86)”.
The ISE (integrated scripting environment) is a handy tool which allows you to write scripts on the fly, and
also has a convenient look-up for all the PowerShell commands.

Two Ways of Extending PowerShell:
A. PSSnapins:
Definition: PSSnapins are legacy extensions in PowerShell used to add cmdlets, providers, and sometimes types to the environment.
Usage: Loaded using Add-PSSnapin cmdlet.
Example: Add-PSSnapin Microsoft.Exchange.Management.PowerShell.SnapIn
B. Modules:
Definition: Modules are a more modern and flexible way to extend PowerShell, encapsulating cmdlets, functions, variables, and other resources in a structured manner.
Usage: Loaded using Import-Module cmdlet. Automatic loading is also supported in recent PowerShell versions.
Example: Import-Module ActiveDirectory

The four types of FORMAT commands in PowerShell are:
1.Format-Wide:
Purpose: Displays wide, table-like views of selected properties of objects.
Usage Example: Get-Process | Format-Wide -Property Name
2.Format-List:
Purpose: Formats the output as a list of property-value pairs.
Usage Example: Get-Service | Format-List -Property DisplayName, Status
3.Format-Table:
Purpose: Presents tabular data with columns for specified properties.
Usage Example: Get-EventLog -LogName Application | Format-Table -Property TimeGenerated, EntryType, Source
4.Format-Custom:
Purpose: Provides a detailed, customizable view of objects.
Usage Example: Get-Command Format-Custom

Two ways to find all the sql services are on one server in PowerShell:
1.WMI Query for SQL Services:
Command: Get-WmiObject Win32_Service | Where-Object { $_.Name -like "sql" }
Description: Uses WMI (Windows Management Instrumentation) to query all services with names containing "sql" and filters the results.
2.Get-Service for SQL Services:
Command: get-service sql
Description: Utilizes the Get-Service cmdlet with a wildcard pattern to retrieve all services whose names start with "sql."

Platforms of PowerShell:
1. .NET Framework
2. .NET Core

PowerShell Consists of different OS:
1. Windows 7
2. Windows Server 2008 R2
3. Mac OS 10.12
4. Ubuntu

PowerShell commands related to files and directories:
1.mkdir (alias for New-Item):
Command: mkdir NewDirectory
Description: Creates a new directory with the specified name.
2.rm (alias for Remove-Item):
Command: rm File.txt
Description: Removes or deletes a file or directory.
3.ls (alias for Get-ChildItem):
Command: ls -Path C:\Directory
Description: Lists files and directories in the specified path. Can be customized with various parameters for detailed information.
4.mv (alias for Move-Item):
Command: mv SourceFile.txt Destination\
Description: Moves a file or directory to a new location.
5.cp (alias for Copy-Item):
Command: cp SourceFile.txt Destination\
Description: Copies a file or directory to a new location

Command keeps all history in Documents folder and can be accessed even after closing powershell:
To keep a history of PowerShell commands in a file that persists even after closing PowerShell, you can use the Start-Transcript cmdlet. This cmdlet records all output, including errors and input commands, to a text file. Here's how you can use it:
Start-Transcript -Path "$HOME\Documents\PowerShellHistory.txt"
This command starts recording the session and saves it to a text file named "PowerShellHistory.txt" in the Documents folder. After running this command, all your commands and their output will be logged to that file.
To stop recording, you can use the Stop-Transcript cmdlet:
Stop-Transcript
This will close the recording session, and you can find the transcript file in your Documents folder. You can open the transcript file in a text editor to review your command history even after closing PowerShell.

"Get-Command -noun s*" cmdlet:
The Get-Command cmdlet retrieves information about all the cmdlets that are installed on the computer. This includes cmdlets, aliases, functions, filters, scripts, and applications. The -noun parameter specifies that only the cmdlets whose names start with the letter s should be returned.
For example, to get a list of all the cmdlets whose names start with the letter s, you would use the following command:
Get-Command -Noun s*
This would return a list of all the cmdlets whose names start with the letter s, such as Get-Service, Set-Service, and Stop-Service.
The Get-Command cmdlet can be used to get information about a specific cmdlet, or to get a list of all the cmdlets that are installed on the computer. This information can be used to help you learn how to use PowerShell cmdlets, or to troubleshoot problems that you might be having with PowerShell.

"get-help get-service -examples" cmdlet
The get-help get-service -examples cmdlet displays examples of how to use the Get-Service cmdlet.
The Get-Service cmdlet is used to get a list of all the services that are running on a local or remote computer. It can also be used to get information about a specific service, such as its status, startup type, and description.
The get-help get-service -examples cmdlet can be used to learn how to use the Get-Service cmdlet to perform specific tasks, such as:
Getting a list of all the services that are running on a local computer
Getting information about a specific service
Starting, stopping, or restarting a service
Changing the startup type of a service
The get-help get-service -examples cmdlet is a valuable tool for learning how to use the Get-Service cmdlet to manage services on Windows computers.

A powerShell command using pipeline for a child item in path home and search recursively where the length of the file is greater than 20 MB:
Get-ChildItem -Path $HOME -Recurse | Where-Object {$_.Length -gt 20MB} | Select-Object -ExpandProperty FullName
This command will:
-Use Get-ChildItem to list all child items (files and folders) in the user's home directory ($HOME).
-Use the -Recurse parameter to search all subdirectories recursively.
-Pipe the results to Where-Object to filter for items with a Length property greater than 20 Megabytes (MB).
-Pipe the filtered results to Select-Object with the -ExpandProperty parameter to only return the full path of each matching file.
This command will output a list of full paths to all files in your home directory and subdirectories that are larger than 20 MB.

Pipelines in PowerShell:
A pipeline is a powerful feature in PowerShell that allows you to chain commands together, sending the output of one command directly to the next as input. This allows you to build complex workflows and automate tasks efficiently.
Here's an example:
Get all files in the current directory and filter for those with "txt" extension, then sort by size and display the top 5 largest files.
Get-ChildItem -Path . -Filter "*.txt" | Sort-Object -Property Length -Descending | Select-Object -First 5
Breakdown:
-Get-ChildItem retrieves all child items in the current directory.
-Path. specifies the current directory.
-Filter "*.txt" filters for files with the "txt" extension.
-The output is piped to Sort-Object.
-Property Length specifies that sorting should be done based on the "Length" property (file size).
-Descending sorts in descending order, showing the largest files first.
-The output is piped to Select-Object.
-First 5 selects only the first 5 objects in the sorted list.
Sorting Processes by ID:
Here's the command to sort running processes on your computer by ID:
Get-Process | Sort-Object -Property Id -Ascending
Breakdown:
-Get-Process retrieves information about all running processes.
-The output is piped to Sort-Object.
-Property Id specifies that sorting should be done based on the "ID" property.
-Ascending sorts in ascending order, listing processes with the lowest IDs first.
This command will display a list of running processes with their IDs sorted from smallest to largest.

PowerShell Variables:
Variables are the fundamental part of the Windows PowerShell. We can store all the types of values in the PowerShell variables. For example, we can store the result of commands, and the elements which are used in expressions and commands, such as paths, names, settings, and values. In fact, they store the objects specifically, Microsoft .NET Framework objects.
A variable is a unit of memory in which the data is stored. In Windows PowerShell, the name of a variable starts with the dollar ($) sign, such as $process, $a. The name of the variables are not case-sensitive, and they include spaces and special characters. By default, the value of all the variables in a PowerShell is $null.
In PowerShell, variables hold any type of values while executing the commands. The variables store the result from a command, function, and expression. Variables are declared using $ sign before the variable name. For example, to store the output of the Get-Process command in a variable, you would use the following command:
$process = Get-Process
You can then use the $process variable to access the output of the Get-Process command. For example, to display the name of the first process in the $process variable, you would use the following command:
Write-Host $process[0].Name
Variables can also be used to store arrays of data. For example, to store the names of all the processes running on the local computer in an array, you would use the following command:
$processes = Get-Process | Select-Object -Property Name
You can then use the $processes array to access the names of all the processes running on the local computer. For example, to display the name of each process in the $processes array, you would use the following command:
foreach ($process in $processes) {
    Write-Host $process.Name
}
Variables are a powerful tool that can be used to simplify your PowerShell scripts. By using variables, you can avoid repeating the same commands multiple times and you can make your scripts more readable and maintainable.

Types of Variables:
Following are the different types of variables in the Windows PowerShell-
User-created Variables: Those variables which are created and maintained by the user are called user-created variables. The variables that we create at the PowerShell command line exist only while the Window of PowerShell is open. When the Window of PowerShell is closed, the variables are also deleted. We can create the variables in the scripts with the local, global, or script scope.
Automatic Variables: Those variables which store the state of PowerShell are called automatic variables. The PowerShell creates this type of variable, and their values are changed by the PowerShell to maintain their accuracy. The user cannot change the values of these variables.
Preference Variables: Preference variables are those variables that store the user preferences for the Windows PowerShell. The Windows PowerShell creates this type of variable, and they are populated with the default values. Any user can change the value of preference variables.

The key characteristics of PowerShell are:
It is object-based and not text based.
Commands are able to be modified to suit a particular task.
It is a command line interpreter and scripting environment.

Advantages of PowerShell:
Following are the few benefits of a PowerShell:
-It is easy to learn and implement.
-It is an object-based scripting language.
-It provides more functions as compared to VBScript and cmd.exe
-PowerShell supports automation platform, which is also an important factor.
-We can also execute a .NET code in PowerShell.
-In PowerShell, there is no need to specify the "type" of a variable.
-It is also interactive. It allows programmers to try first at a console and then work with more complicated scripts.
-There is a concept of background jobs in PowerShell scripting.
-It provides the feature of Reusability. The scripts which are written once to perform a particular task can be saved for later use. And can be merged with other scripts to perform various tasks. So, repetitive tasks can be performed to execute the tasks. It saves time and money of administrator in configuring the machines.

Disadvantages of PowerShell:
Following are the few disadvantages of PowerShell:
-Framework: It requires .NET framework.
-Object-based: With most shells, the text-based commands are used to get the work done while writing scripts. If a user switches to Windows PowerShell from some other type of shells, he will have to get used to a different way of thinking. Due to this, some users need more time to understand the PowerShell.
-Security risks: Another drawback of using PowerShell is that it can create some potential security risks. Many professionals of IT use it as a way to connect remotely to other servers and computers. During this process, PowerShell can leave some holes open for security breaches. It is the major disadvantages of using PowerShell script.
-Web Server: Another drawback of PowerShell is that it requires a user to run a web server on his server when utilizing remote functionality.

Powershell features:
1. Windows PowerShell Workflow: Workflow capabilities have been introduced in Windows PowerShell version 3.0. It is designed particularly to help us by performing long-time and effort-consuming complex tasks across different and multiple devices at different locations.
2. Desired State Configuration: DSC is the feature of a Windows PowerShell which provides a collection of language extensions, resources, and cmdlets that can be used to configure the software declaratively.
3. Background job: Windows PowerShell introduced the concept of background jobs that run scripts and cmdlets asynchronously on the remote and local machines in the background without affecting the user interface or interacting with the console.
4. Scheduled job: It is similar to the background job. Both the jobs execute asynchronously in the background without affecting the interface, but the main difference is that the background jobs are started manually.
5. Error-handling: Windows PowerShell provides the error-handling mechanism through the Try{ }, Catch { }, and Finally {} blocks as in .NET language.
6. PowerShell remoting: This feature of Windows PowerShell allows the execution of cmdlets on remote systems which help to manage the set of remote computers from one single machine.
7. Script debugging: It is a feature of PowerShell to examine the script, function, command, or expressions while PowerShell is running. PowerShell script debugger includes the set of cmdlets which allow to set and manage breakpoints and view the call stack.
8. Tab expansion: Tab expansion is an implementation of auto-completion, which completes the cmdlets, properties, and parameter names by pressing the Tab key once.
9. Steppable pipeline: This feature allows the splitting of script blocks into a steppable pipeline. And then it gives the option to call the begin(), process(), and end() methods of script block to control the execution sequence.
10. Constrained runspaces: It allows the creation of PowerShell runspaces with the set of constraints which includes the ability to access and execution of scripts, cmdlets, and language elements.
11. Windows PowerShell web access: PowerShell console introduced a web-based version in Windows Server 2012. Here, we can run PowerShell cmdlets from any web browser which is not available on desktops but also on any tablet or mobile devices.
12. Network file transfer: This feature provides the native support for prioritized, and asynchronous transfer of files between the machines using BITS (Background Intelligent Transfer Service).
13. Windows PowerShell Integrated Scripting Environment (ISE): It is the host GUI based application for the Windows PowerShell. This feature provides tab completion, multiline editing, syntax coloring, context-sensitive help, selective execution, and support for right-to-left languages.
14. Transactions: This feature of Windows PowerShell enables us to start a transaction, to indicate which command is a part of it, and to either rollback or commit a transaction.

PowerShell Comments:
When you want to help others by providing the information about a code, then you must use the comments in that code.
Just like other programming or scripting languages, you can give the comments in a PowerShell for the documentation purpose.
In PowerShell, there are two types of comments:
1) Single-line Comment - Single line comments are those comments in which you can type a hash symbol # at the beginning of each line. Everything to the right of the hash symbol will be ignored. If you write the multiple lines in a script, you had to use the hash # symbol at the starting of each line.
2) Multiple-line comment or comment block - With PowerShell 2.0 or above, multiple line comments or block comments have been introduced. To comment the multiple lines, put the <# symbol at the beginning of the first line and #> symbol at the end of the last line.


Navigation in Powershell:
A nice thing about PowerShell is you always know where you are because it tells you in the prompt.
PS C:\Users\niks>
Our first command is Get-ChildItem.
Go ahead and type it in, and hit enter.
You’ll see a list of everything in your current directory.
PS C:\Users\niks> gci

Moving Between Directories in Powershell:
To move to your desktop, we will use the Set-Location cmdlet. Enter
PS C:\Users\niks> sl .\Desktop\
PS C:\Users\niks\Desktop>
We can move back to the YOURUSERNAME directory by typing, Don’t leave out the space!
PS C:\Users\niks\Desktop> sl
PS C:\Users\niks>

Creating New Directories:
Let us make a directory where we can store everything we are using for this lesson. Navigate back home by typing
PS C:\Users\niks\Desktop> sl ~
PS C:\Users\niks>
We’ll make a new directory inside of your YOURUSERNAME directory.
To do this, we use the command mkdir.
Call your directory whatever you want, but try not to use spaces, as these make working on the command line more complicated than necessary.
PS C:\Users\niks> mkdir abc

Deletion:
Now that you can see the results of what you are doing in PowerShell. Let us learn to delete things - for
instance, that directory with the long name. First, create a few more directories. Name them “dir,” “dir1,”and “dir2.” You can make all three with a single command by typing-
PS C:\Users\niks> mkdir dir, dir1, dir2
Now, let us get rid of that long-named directory. To do this, we use the cmdlet Remove-Item or just rm. You have to be very careful with this cmdlet, because it does not put things in your recycle bin. It deletes them permanently. Gone. Type in rm followed by a space and the long-named directory’s name. You’ll probably want to use tab for auto-completion.
PS C:\Users\niks> rm .\dir\
Multiple deletes at a time is possible-
PS C:\Users\niks> rm dir1 dir2

Find Powershell commands:
• The first thing to keep in mind is that in Windows PowerShell, not everything is a cmdlet.
• There are language statements, functions, aliases, various objects (from the .NET Framework or COM), and even other executables—all of which are utilisable from within Windows PowerShell.
• In Windows 8 Consumer Preview, this means you have around 1000 commands from which to choose.
• In Windows 7, the situation is not quite so overwhelming, but still, you need to know how to find what you want.
Two cmdlets are essential for discovering Windows PowerShell commands.
The first is the Get-Command cmdlet, and the second is the Get-Help cmdlet.
At first glance, the Get-Command cmdlet might not appear to be all that useful. For example, you provide it with the name of a cmdlet, and basically what returns is the name of the cmdlet.
This command is shown below:
PS C:\Users\niks> Get-Command Get-Process
• The command and the output associated with the command illustrate the problem.
• The default output does not appear to display much more information than you knew when you typed in the command.
• You figured it was a cmdlet, you knew the name of Get-Process, and the definition does not add much additional information.
Point to remember, everything in Windows PowerShell is an object. In fact, the Get-Command cmdlet returns a CmdletInfo object. 

Get-Command:
The PowerShell Get-Command cmdlet is used to get a list of all the PowerShell commands that are installed on the computer. This cmdlet includes functions, other cmdlets, aliases, filters, scripts, and applications. You can use the Get-Command cmdlet to get only those commands that have been imported into the current session by using the -ListImported parameter. With the starting of Windows PowerShell 5.0, this cmdlet displays a version column by default.

Active Directory and PowerShell:
• The one thing that makes system administration on the Windows platform unique is its interaction with Active Directory.
• As the centralised authorisation, authentication, and information store for Windows networks, Active Directory automation forms the core of many enterprise administration tasks.
• In PowerShell version one, the primary way to interact with Active Directory came through its support for Active Directory Service Interface (ADSI) type shortcuts.
• While PowerShell version two was under development, the Active Directory team created an immensely feature-filled PowerShell module to manage Active Directory domains.
Working with the Active Directory module has two requirements:
Support from the server: This module works with any domain that has enabled the Active Directory Web Services feature. Windows Server 2008 R2 enables this feature by default on Active Directory instances, and you can install it on any recent server operating system from Windows Server 2003 on.
Support from the client: The module itself is included in the Windows 7 Remote Server Administration Tools (RSAT) package. After downloading and installing the package, you can enable it through the “Turn Windows Features On or Off” dialogue in the Control Panel. The Active Directory module for Windows PowerShell is a PowerShell module that consolidates a group of cmdlets.
You can use these cmdlets to manage your Active Directory domains, Active Directory Lightweight Directory Services (AD LDS) configuration sets, and Active Directory Database Mounting Tool instances in a single, self-contained package.
If you do not have the Active Directory module installed on your machine, you need to download the correct Remote Server Administration Tools (RSAT) package for your OS.
If you are running Windows 7, you will also need to run the import-module Active Directory command from an elevated PowerShell prompt.

Network configuration cmdlets:
Network troubleshooting is part of any System Administrator’s life.
Maybe you need to check the IP address of a machine or test if its networking connection is working.
Maybe you need to see if DNS is properly configured or check the latency between two hosts.
If you have been in this field long enough, you probably have a few favourite commands that you learned years ago and use on a regular basis, like IPCONFIG or PING.
There are literally hundreds of networking-related PowerShell cmdlets in Windows these days. 
Just try out this command on your machine: Get-Command -Module Net* | Group Module
But more important than knowing every one of them, is to know the most useful cmdlets that have the potential to replace those old commands that you cannot live without.
And it’s when you combine the many networking cmdlets in ways that only PowerShell can do that you’ll find amazing new troubleshooting abilities.


IPCONFIG:
This command has many options, but the most common usage is just to show the IP address, subnet mask and default gateway for each network adapter in a machine.
Get-NetIPConfiguration or Get-NetIPAddress
Sample command lines:
Get-NetIPConfiguration
Get-NetIPAddress | Sort InterfaceIndex | FT InterfaceIndex, InterfaceAlias, AddressFamily,
IPAddress, PrefixLength -Autosize
Get-NetIPAddress | ? AddressFamily -eq IPv4 | FT –AutoSize
Get-NetAdapter Wi-Fi | Get-NetIPAddress | FT -AutoSize

PING:
Checks connectivity to a specific host. Commonly used to check for liveliness, but also used to measure network latency.
Test-NetConnection
Sample command lines:
Test-NetConnection www.microsoft.com
Test-NetConnection -ComputerName www.microsoft.com -InformationLevel Detailed
Test-NetConnection -ComputerName www.microsoft.com | Select –ExpandProperty
PingReplyDetails | FT Address, Status, RoundTripTime

NSLOOKUP:
Name server lookup. Mostly used to find the IP address for a given DNS name (or vice-
versa). Has many, many options.
Resolve-DnsName
Sample command lines:
Resolve-DnsName www.microsoft.com
Resolve-DnsName microsoft.com -type SOA
Resolve-DnsName microsoft.com -Server 8.8.8.8 –Type A

ROUTE:
Shows the IP routes in a given system (also used to add and delete routes)
Get-NetRoute (also New-NetRoute and Remove-NetRoute)
Sample command lines:
Get-NetRoute -Protocol Local -DestinationPrefix 192.168*
Get-NetAdapter Wi-Fi | Get-NetRoute

NETSAT:
Shows current TCP/IP network connections.
Get-NetTCPConnection
Sample command lines:
Get-NetTCPConnection | Group State, RemotePort | Sort Count | FT Count, Name –Autosize
Get-NetTCPConnection | ? State -eq Established | FT –Autosize
Get-NetTCPConnection | ? State -eq Established | ? RemoteAddress -notlike 127* | % { $_; Resolve-DnsName $_.RemoteAddress -type PTR -ErrorAction SilentlyContinue }

The Powershell Pipeline:
• Pipelines act like a series of connected segments of pipe.
• Items moving along the pipeline pass through each segment.
• To create a pipeline in PowerShell, you connect commands together with the pipe operator "|".
• The output of each command is used as input to the next command.
• The notation used for pipelines is similar to the notation used in other shells.
• At first glance, it may not be apparent how pipelines are different in PowerShell.
• Although you see text on the screen, PowerShell pipes object, not text, between commands.
• Pipelines are arguably the most valuable concept used in command-line interfaces.
• When used properly, pipelines reduce the effort of using complex commands and make it easier to see the flow of work for the commands.
• Each command in a pipeline (called a pipeline element) passes its output to the next command in the pipeline, item-by-item.
• Commands don't have to handle more than one item at a time.
• The result is reduced resource consumption and the ability to begin getting the output immediately.

Objects in the pipeline:
When you run a cmdlet in PowerShell, you see text output because it is necessary to represent objects as text in a console window. The text output may not display all of the properties of the object being output.
For example, consider the Get-Location cmdlet.
When you pipe the output to the Get-Member cmdlet you get information about the object returned by Get-Location.

Selecting object:
You can use the Select-Object cmdlet to create new, custom Windows PowerShell objects that contain properties selected from the objects you use to create them. Type the following command to create a new object that includes only the Name and FreeSpace properties of the Win32_LogicalDisk WMI class.
Get-WmiObject -Class Win32_LogicalDisk | Select-Object -Property Name, FreeSpace

Sorting Objects:
We can organise displayed data to make it easier to scan by using the Sort-Object cmdlet. Sort-Object takes the name of one or more properties to sort on and returns data sorted by the values of those properties. Consider the problem of listing Win32_SystemDriver instances. 
If we want to sort by State and then by Name, we can do it by typing:
Get-WmiObject -Class Win32_SystemDriver | Sort-Object -Property State,Name | Format-Table -Property Name,State,Started,DisplayName - AutoSize -Wrap
You can also sort the objects in reverse order by specifying the Descending parameter. The reverses sort order, so that names are sorted in reverse alphabetical order and numbers are sorted by descending size.
Get-WmiObject -Class Win32_SystemDriver | Sort-Object -Property State,Name -Descending | Format-Table -Property Name,State,Started,DisplayName - AutoSize -Wrap


Filtering Objects:
• The key to making the most of Windows PowerShell is to understand how objects and the pipeline wor together to let you retrieve exactly the information you need.
• Each command in the pipeline generates one or more objects and passes them down the pipeline to the next command.
• Integral to this process is the ability to filter the objects and their data as they pass from one command the next.
• To that end, PowerShell includes a number of cmdlets that, in one way or another, let you create commands that refine your pipeline's output.
Here we discuss five of those cmdlets-
• Where-Object: Where-Object is one of the most commonly used cmdlets in PowerShell and probably the one most often used for filtering data. This cmdlet filters objects passed down the pipeline based on the search criteria you specify in a script block included with the cmdlet. In other words, the script block determines which objects are permitted to continue down the pipeline and which are not.
• Select-Object: There might be times when you need to refine your results a bit differently from what the Where-Object cmdlet provides. That is where the Select-Object cmdlet comes in. Using this cmdlet, you can filter your results based on property names, a number of objects, or other criter For example, the statement pipes the Get-Process cmdlet's output to the Select-Object cmdlet and specific that only the ProcessName and CPU properties be returned.
• Select-String: The Select-String cmdlet lets you move into new territory: You can use it to search an input string or a file's contents for a specific value. This cmdlet searches for text or text patterns within the target data and returns matching the content. It operates on a line-by-line basis, filtering out all lines that don't contain the specified string and returning those that do. In addition, the cmdlet lets you specify that nonmatching lines are returned instead of matching lines. You can even test for the existence of matches, without returning the actual data.
• ForEach-Object: The ForEach-Object cmdlet in PowerShell is used to perform an operation on each item in a collection or pipeline. It allows you to iterate through a collection of objects and apply a script block to each item. This cmdlet is commonly used in pipelines to perform actions on individual items as they pass through. ForEach-Object iterates through each item in a collection or pipeline, applying a script block to perform customized actions on individual objects. Example: 1, 2, 3, 4 | ForEach-Object { $_ * 2 } multiplies each number by 2, yielding 2, 4, 6, 8.
• Out-GridView: The last PowerShell cmdlet related to filtering that I want to demonstrate is the Out-GridView cmdlet. This cmdlet sends your output to a new window that displays your data in a grid. You can then filter the returned data however you want, without having to generate additional PowerShell commands. To open the grid window, you simply pipe your results to the Out-GridView cmdlet.

Sending pipeline data as output:
The Out-File cmdlet sends output to a file.
You can use this cmdlet instead of the redirection operator (>) when you need to use its parameters.
This command sends a list of processes on the computer to the Process.txt file. If the file does not exist, Out-File creates it.
• The Out cmdlets do not format objects; they just render them and send them to the specified display destination.
• If you send an unformatted object to an Out cmdlet, the cmdlet sends it to a formatting cmdlet before rendering it.
• The Out cmdlets do not have parameters for names or file paths.
• To send data to a cmdlet that contains the Out verb (an Out cmdlet), use a pipeline operator (|) to send the output of a PowerShell command to the cmdlet.
• You can also store data in a variable and use the InputObject parameter to pass the data to the cmdlet

Cmdlet:
The cmdlets in a PowerShell perform an action and returns a Microsoft .NET framework object to the next command in the pipeline. Cmdlets can receive objects as input and can also output their results as objects, which makes them suitable for use as recipients in a pipeline.
If you write a cmdlet, you must implement a cmdlet class which derives from one of two specialized cmdlet base classes. A derived class must:
-Declare an attribute which identifies the derived class as a cmdlet.
-Define the public properties which are decorated with the attributes that identify the public properties as parameters of a cmdlet.
-To process records, it overrides one or more of the input processing methods.
-An assembly can be loaded which contains the class directly by using an Import-Module cmdlet, or we can create a host application which loads the assembly by using a System.Management.Automation.Runspaces.Initialsessionstate API. Both methods provide programmatic and command-line access to cmdlet functionality.

Cmdlets vs Command:
A cmdlet or "Command let" is a lightweight command used in the Windows PowerShell environment. The Windows PowerShell runtime invokes these cmdlets at command prompt. You can create and invoke them programmatically through Windows PowerShell APIs.
Cmdlets are way different from commands in other command-shell environments in the following manners −
Cmdlets are .NET Framework class objects; and not just stand-alone executables.
Cmdlets can be easily constructed from as few as a dozen lines of code.
Parsing, error presentation, and output formatting are not handled by cmdlets. It is done by the Windows PowerShell runtime.
Cmdlets process works on objects not on text stream and objects can be passed as output for pipelining.
Cmdlets are record-based as they process a single object at a time.

Powershell Loop:
PowerShell loops are used to repeat a set of commands until a certain condition is met. They are an essential part of programming, and PowerShell is no exception. Loops allow you to iterate through collections and repeat tasks until a condition is met. Loops can drastically enhance your PowerShell scripts and take your automation to the next level.
There are four main types of loops in PowerShell:
For Loop:The for loop is commonly used when the number of times (iteration count) a command or process needs to run, is already known.
ForEach-Object Loop:The foreach loop is used to iterate through a collection of objects.
While Loop:The while loop is used to repeat a set of commands until a certain condition is met.
Do While Loop:The do while loop is similar to the while loop, but the condition is checked at the end of the loop instead of the beginning.

Powershell - Conditions:
Decision making structures have one or more conditions to be evaluated or tested by the program, along with a statement or statements that are to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.
PowerShell scripting language provides following types of decision making statements.
1. if statement: An if statement consists of a boolean expression followed by one or more statements.
2. if...else statement: An if statement can be followed by an optional else statement, which executes when the boolean expression is false.
3. nested if statement: You can use one if or elseif statement inside another if or elseif statement(s).
4. switch statement: A switch statement allows a variable to be tested for equality against a list of values.

Powershell - Scripting:
Windows PowerShell is a command-line shell and scripting language designed especially for system administration. Its analogue in Linux is called as Bash Scripting. Built on the .NET Framework, Windows PowerShell helps IT professionals to control and automate the administration of the Windows operating system and applications that run on Windows Server environment.
Windows PowerShell commands, called cmdlets, let you manage the computers from the command line. Windows PowerShell providers let you access data stores, such as the Registry and Certificate Store, as easily as you access the file system.
In addition, Windows PowerShell has a rich expression parser and a fully developed scripting language. So in simple words you can complete all the tasks that you do with GUI and much more. Windows PowerShell Scripting is a fully developed scripting language and has a rich expression parser/
Features:
Cmdlets − Cmdlets perform common system administration tasks, for example managing the registry, services, processes, event logs, and using Windows Management Instrumentation (WMI).
Task oriented − PowerShell scripting language is task based and provide supports for existing scripts and command-line tools.
Consistent design − As cmdlets and system data stores use common syntax and have common naming conventions, data sharing is easy. The output from one cmdlet can be pipelined to another cmdlet without any manipulation.
Simple to Use − Simplified, command-based navigation lets users navigate the registry and other data stores similar to the file system navigation.
Object based − PowerShell possesses powerful object manipulation capabilities. Objects can be sent to other tools or databases directly.
Extensible interface. − PowerShell is customizable as independent software vendors and enterprise developers can build custom tools and utilities using PowerShell to administer their software.

Uses of PowerShell Pipiline:
The PowerShell pipeline is a feature of the PowerShell shell and scripting language that allows you to chain together commands to build a single 'pipeline' which simplifies code, allows parallel processing and more.
Commands in a pipeline act like human runners in a relay race. The output of one command is passed as the input to the next command, and so on. This allows you to automate complex tasks with just a few lines of code.
For example, we can use the pipeline to:
-Get a list of all the files in a directory, and then sort them by size.
-Get the contents of a website, and then extract all the links.
-Convert a video file to a different format, and then compress it.


PowerShell Operators:
1. Arithmetic Operators:
Definition: Perform mathematical operations on values.
Operator Names: + (Addition), - (Subtraction), * (Multiplication), / (Division), % (Modulus)
2. Assignment Operators:
Definition: Assign values to variables.
Operator Names: = (Assignment), += (Add and Assign), -=, *=, /=, %=
3. Comparison Operators:
Definition: Compare values and return a Boolean result.
Operator Names: -eq (Equal), -ne (Not Equal), -gt (Greater Than), -lt (Less Than), -ge (Greater Than or Equal), -le (Less Than or Equal)
4. Logical Operators:
Definition: Combine or modify Boolean values.
Operator Names: -and (Logical AND), -or (Logical OR), -not (Logical NOT)
5. Redirectional Operators:
Definition: Control input/output redirection.
Operator Names: > (Output to a file), < (Input from a file), >> (Append to a file)
6. Split and Join Operators:
Definition: Split and join strings.
Operator Names: -split (Split a string), -join (Join elements into a string)
7. Type Operators:
Definition: Check and manipulate data types.
Operator Names: -is (Is of a certain type), -as (Casting or conversion)
8. Unary Operators:
Definition: Operate on a single operand.
Operator Names: - (Negation), + (Unary plus), ! (Logical NOT)

Uses/Needs/Importance of powershell:
-It is both a scripting language and a command-line Shell.
-It can interact with a different number of technologies.
-Windows PowerShell allows complete access to all the types in the .NET framework.
-PowerShell is object-based.
-Many interfaces of GUI that Microsoft designed for its various products are front end interfaces to PowerShell.
-It is more secure than running VBScript or other scripting languages.
-It allows performing repetitive tasks more efficiently by combining multiple commands and by writing scripts. Suppose, a system administrator wants to create hundreds of active directory users, he can achieve this with the help of only some PowerShell cmdlets placed in a script.
-Many complex and time-consuming configurations and tasks can be done in a second with simple cmdlets of PowerShell.

Powershell - Brackets:
There are three types of brackets in PowerShell:
Round/Parenthesis brackets ()
are used for grouping arguments and expressions. For example, the expression (1 + 2) * 3 will be evaluated as (1 + 2) * 3 = 9.
Square brackets []
are used for indexing arrays and accessing hash table elements. For example, the expression $array will return the first element of the array $array.
Curly brackets {}
are used for creating blocks of code. For example, the following code will create a loop that prints the numbers from 1 to 10:
for ($i = 1; $i -le 10; $i++) {
    Write-Host $i
}

Significance of brackets in PowerShell:
The significance of brackets in PowerShell is that they allow you to control the order of operations in expressions and to create blocks of code. This can make your code more readable and easier to maintain.
-Script Blocks: {} define script blocks for encapsulating commands.
-Scope: Establish variable scope within a script block.
-Array Declaration: Brackets @() represent arrays in PowerShell.
-Hashtable Declaration: Curly braces {} define hashtables for key-value pairs.

Command-Name and Description:
Add-content: This cmdlet adds the content to the specified file.
Add-Computer: This cmdlet adds the local computer to a domain or workgroup.
Add-History: This cmdlet is used to add the command in the history.
Add-jobTrigger: This cmdlet adds the job triggers to the scheduled jobs.
Add-member: The cmdlet adds the custom methods or properties to an instance of a PowerShell object.
Add-type: This cmdlet adds a Microsoft .NET framework class to a Windows PowerShell session.
Clear-Content: This cmdlet deletes the content of a file, but not delete that file.
Clear-History: This cmdlet deletes the entries from the command history.
Clear-Item: This cmdlet clears the value of item or variable, but not clear that item or a variable.
Clear-ItemProperty: This cmdlet clears the value of a property but not delete that property.
Clear-Variable: This cmdlet deletes the value of a variable.
Clear-Host: This cmdlet clears the display of the host program.
Copy-ItemProperty: This cmdlet copies a value and property from a specified location to another location.
Copy-Item: This cmdlet copies an item from one location to another.
Complete-Transaction: This cmdlet commits the active transaction.
Compare-object: This cmdlet compares two sets of objects.
Disable-PSBreakpoint: This Cmdlet disables the breakpoint in the current console.
Enable-PSBreakpoint: This Cmdlet enables the breakpoint in the current console.
Find-package: This cmdlet finds the software packages in the available packages sources.
Find-script: This cmdlet is used to find a script
ForEach-Object: This cmdlet performs an operation on each item in a collection of input objects.
Get-Alias: This cmdlet gets the aliases for the current session.
Get-childItem: This cmdlet gets the item and the child items in one or more specified locations.
Get-Command: This cmdlet is used to get all commands.
Get-Content: This cmdlet gets the content of the file at the specified location.
Get-Date: This cmdlet is used to get the current date and time.
Get-ExecutionPolicy: This cmdlet gets the execution policy for the current session.
Get-Help: This cmdlet displays information about PowerShell commands and concepts.
Get-History: This cmdlet displays a list of commands which are entered during the current session.
Get-host: This cmdlet gets an object which represents the current host program.
Get-InstalledScript: This cmdlet gets a script which is installed for the current user.
Get-Item: This cmdlet gets the item or a file at a particular location.
Get-ItemProperty: This cmdlet gets the properties of a particular item.
Get-Location: This cmdlet displays the current working location.
Get-PSBreakpoint: This cmdlet gets the breakpoint which is set in the current session.
Get-Package: This cmdlet displays the list of all installed packages by using the package management.
Get-Process: This cmdlet gets the processes which are running on local or remote computers.
Get-Service: This cmdlet gets the services on local or remote computers.
Get-Transaction: This cmdlet gets the currently active transaction.
Get-Variable: This cmdlet gets the variable in the current console.
Install-package: This cmdlet is used to install one or more software packages.
Install-script: This cmdlet is used to install a script.
Invoke-commands: This cmdlet executes commands on local and remote computers.
Move-Item: This cmdlet is used to move an item from one location to another.
Move-ItemProperty: This cmdlet is used to move the property of an item from one location to another.
New-alias: This cmdlet creates a new alias.
New-Item: This cmdlet creates a new item.
New-ItemProperty: This cmdlet creates a new property for an item and sets its value.
New-Service: This cmdlet creates a new Window service.
New-variable: This cmdlet creates a new variable.
Read-Host: This cmdlet reads a line of inputs from the console.
Remove-computer: This cmdlet removes a local computer from its domain.
Remove-Item: This cmdlet deletes the particular item.
Remove-ItemProperty: This cmdlet deletes the property & its value from an item.
Remove-job: This cmdlet removes the background job of Windows PowerShell.
Remove-PSBreakpoint: This cmdlet deletes the breakpoint from the current console.
Remove-variable: This cmdlet deletes a variable with its value.
Rename-computer: This cmdlet is used to rename a computer.
Restart-Service: This cmdlet stops and starts one or more services.
Restart-computer: This cmdlet is used to restart the Windows operating system on local and remote computers.
Resume-job: This cmdlet is used to restart a suspended job.
Save-Help: It is used to download and save the newest help files to a file system directory.
Save-packages: This cmdlet is used to save the packages to the local computer without installing them.
Save-Script: This cmdlet is used to save a script.
Select-string: This cmdlet is used to find the text in string or files.
Send-MailMessage: This cmdlet is used to send an e-mail message.
Set-Alias: This cmdlet creates or changes the alias for a cmdlet in the current Windows PowerShell.
Set-content: This cmdlet writes the content in a file.
Set-Date: This cmdlet changes the time of the system.
Set-Item: This cmdlet changes the value of an item to the value specified in the command.
Set-ItemProperty: This cmdlet change or creates the value of the property of an item.
Set-Location: This cmdlet is used to set the current working location to a particular location.
Set-PSBreakpoint: This cmdlet sets a breakpoint on a command, line or a variable.
Set-ScheduledJob: This cmdlet changes the scheduled Job.
Set-Service: This cmdlet stops, start and suspend services, and changes its properties.
Set-variable: This cmdlet sets the value of the variable.
Show-command: This cmdlet creates the Windows PowerShell commands in a graphical command Window.
Sort-Object: This cmdlet sorts the object by the property value.
Start-Job: This cmdlet starts a background job of Windows PowerShell.
Start-Process: This cmdlet starts on or more process on a local computer.
Start-services: This cmdlet starts one or more services which are stopped.
Start-transaction: This cmdlet starts a transaction.
Stop-Computer: This cmdlet shut down the local and remote computers.
Stop-Job: This cmdlet stops a background job of Windows PowerShell.
Stop-Process: This cmdlet stops one or more processes.
Stop-Services: This cmdlet stops one or more running services.
Suspend-jobs: This cmdlet temporarily stops the workflow jobs.
Suspend-Service: This cmdlet suspends or pauses one or more running services.
Undo-transaction: This cmdlet rollbacks the active transaction.
Uninstall-module: This cmdlet is used to uninstall a module.
Uninstall-Package: This cmdlet uninstalls one or more packages of software.
Unregister-ScheduledJob: This cmdlet deletes the scheduled jobs on the local computer
Update-Help: This cmdlet is used to download and installs the newest help files on the computer.
Write-Output: This cmdlet sends the particular object down the pipeline to the next command.

Parameters:
-ArgumentList: The -ArgumentList parameter is used to specify an array of arguments. An alias for this parameter is Args. Wildcard characters are not supported.
-Verb: The -Verb parameter is used to specify an array of command verbs. Wildcard characters are accepted.
-Noun: The -Noun parameter is used to specify an array of command nouns. Wildcard characters are accepted.
-Module: The -Module parameter is used to specify an array of modules. It gets those commands which come from the specified modules. The -Module parameter takes the string values, but the value of it can also be a PSModuleInfo object
